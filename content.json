[{"title":".wxss等文件的理解","date":"2017-01-04T08:13:42.000Z","path":"2017/01/04/微信/","text":"微信app.json:是全局配置文件app.wxss:是全局样式 弹性布局:http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool websocket的注意点,ws的发送数据只能是字符串和数字","tags":[]},{"title":"面试总结","date":"2016-12-30T07:56:49.000Z","path":"2016/12/30/面试总结/","text":"面试总结: 新建数组的参数的区别: array(3):返回空, 只有长度为3,array(2,3):返回数值2,3 怎么做逐帧动画 js和精灵图 animation中的steps() js构造函数的继承方法一: B.call(this,属性);//是继承属性 方法二: B.prototype = new A();//要注意A是构造函数的new方法 ie8的兼容问题(怎么解决高度)—hack 移动端的兼容问题(多) \u0010对加密的接口,要怎么跨域获得?–post解决ajax跨域请求(是由后台解决的) 优化 有一个是可以解压png图片的工具,(有一个熊猫的logo) 把小一点的图片转为base64 把图片弄成精灵图 压缩js为min 压缩css为min html5语义化的作用(SEO搜索引擎优化) jq的封装方法($.extend)—怎么封装一个jq的函数 chrome的字体最小只能显示12px 解决方案是用rem 适配??? —相当于响应式布局 也就是布局的处理(rem和%) 布局的垂直居中 display:flex是\u0010弹性布局, dispaly:table 定位,要怎么写? 设置height,再添加line-height padding-top和padding-bottom vue中,计算属性,还有他的好处 vue中,它的生命周期 vue2.0的下标是key,vue1.0的下标是用$index es6的语法 预处理器,喜欢那个,less的好处 ???? EMSAJavaScript是js的部分 ???? Bootstrap的栅格系统 (一行5列,是占多少5/12) ##害怕的: 兼容问题 vue的小知识点 移动端的兼容问题","tags":[]},{"title":"跨域的注意点","date":"2016-12-19T03:10:26.000Z","path":"2016/12/19/跨域/","text":"注意点跨域问题 ajax和跨域jsonp是两个不同的东西,只是刚好jq封装好了,有这个方法 vue框架已经是模块化的数据,如果是图片要require加载 :src=obj.img(要绑定数据) vue框架的图片引入,需要加./当前的文件,否则会报错 a标签的防止跳转 class=”javascript:void(0)”","tags":[]},{"title":"多人开发的环境配置","date":"2016-12-06T03:55:07.000Z","path":"2016/12/06/多人开发/","text":"版本控制器git版本控制器优点:适合多人开发 svn 终端的命令实现smartGit里面的commit 查看状态git status 添加文件的缓存(test.html里面的) git add test.html 用 git commit -m ‘修改的备注’ 提交的仓库 git commit -m &quot;修改的内容&quot; 编辑文件 vim 编辑文件 编辑状态 i u ctrl+C是停止文件处于编辑状态 保存 :wq(保存并退出) :q(是不保存,直接关闭) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293git -version git版本信息cd 跳转目录vim 编辑文件shift: q wqcat readme.txt 打开文件mkdir pro 创建文件夹获取帮助格式 git help &lt;verb&gt;示例git help commit # 按 q 退出帮助//设置用户名git config --global user.name &quot;XXX&quot; //设置邮箱git config --global user.email &quot;XXX@163.com&quot; git init 将一个目录初始化为 Git 仓库$ ls 显示当前文件内容列表$ ls -a 显示所有文件内容列表git clone url 复制一个 Git 仓库git add index.html 添加文件到缓存然后使用 git status git status -s和 git diff 查看有何改动最后用 git commit -m &apos;修改的备注&apos; 提交的仓库git diff 显示已写入缓存与已修改但尚未写入缓存的改动的区别git diff --cached 命令会告诉你有哪些内容已经写入缓存了git diff HEAD 查看已缓存的与未缓存的所有改动git diff –stat 显示摘要而非整个 diffgit reflog命令，是用来记录你每一次执行的命令git commit -a 自动将在提交前将已记录、修改的文件放入缓存区如果你觉得 git add 提交缓存的流程太过繁琐，Git 也允许你用 -a 选项跳过这一步。 基本上这句话的意思就是，为任何已有记录的文件执行 git add —— 也就是说，任何在你最近的提交中已经存在，并且之后被修改的文件。 这让你能够用更 Subversion 方式的流程，修改些文件，然后想要快照所有所做的改动的时候执行 git commit -a。 不过你仍然需要执行 git add 来添加新文件，就像 Subversion 一样。回滚修改记录git reset --hard HEAD^^^^ //一个^回滚一次记录 HEAD~100回滚数git reset --hard id 回滚到指定IDgit reset HEAD 取消缓存已缓存的内容git reset HEAD -- filegit rm 将文件从缓存区移除默认情况下，git rm file 会将文件从缓存区和你的硬盘中（工作目录）删除。 如果要在工作目录中留着该文件，可以使用 git rm --cachedgit mv 命令，但它有点多余 —— 它做得所有事情就是 git rm --cachedgit branch 列出可用的分支git branch (branchname) 创建新分支git branch -d (branchname) 删除分支git checkout (branch) 切换到我们要修改的分支。git checkout -b (branchname) 创建新分支，并立即切换到它git merge 将分支合并到你的当前分支你可以使用 git merge 命令将任何分支合并到当前分支中去git log 显示一个分支中提交的更改记录我们可以用 --oneline 选项来查看历史记录的紧凑简洁的版本。git log –author 只寻找某个特定作者的提交git log –since –before 根据日期过滤提交记录git log –grep 根据提交注释过滤提交记录git log -p 显示每个提交引入的补丁git tag -a v1.0 git tag 给历史记录中的某个重要的一点打上标签git log --decorate 时，我们可以看到我们的标签了：git remote 罗列、添加和删除远端仓库别名git remote 列出远端别名git remote add 为你的项目添加一个新的远端仓库git remote rm 删除现存的某个别名git remote -v简而言之 你可以用 git remote 列出你的远端仓库和那些仓库的链接。 你可以使用 git remote add 添加新的远端仓库，用 git remote rm 删掉已存在的那些。git fetch 从远端仓库下载新分支与数据git pull 从远端仓库提取数据并尝试合并到当前分支第二个会从远端服务器提取新数据的命令是 git pull。 基本上，该命令就是在 git fetch 之后紧接着 git merge 远端分支到你所在的任意分支。 我个人不太喜欢这命令 —— 我更喜欢fetch 和 merge 分开来做。少点魔法，少点问题。 不过，如果你喜欢这主意，你可以看一下 git pull 的 官方文档。git merge [alias]/[branch]git push 推送你的新分支与数据到某个远端仓库 创建支线 git brance 支线名 —&gt;创建支线 git brance —&gt;查看支线 git status –&gt;查看文件,是否存在有修改过的文件 git add 文件名 –&gt;将文件提交到远程git服务器上 git commit -m “修改的注释” git push origin 分支线名 git checkout 支线名 —&gt;切换支线 git checkout -b 分支名 —&gt;创建+切换分支 git merge 分支名 –&gt;合并某分支到当前分支 用码云搭建环境(多人开发) git clone 仓库名 –&gt;下载仓库上的文件 git status –&gt;查看文件 git add 文件名 –&gt;添加文件 git commit -m “注解修改的内容” –&gt;注解修改的提示内容 git push –&gt;是将文件上传(需要用到码云的用户名和密码) 用新浪云搭建环境(多人开发)http://blog.csdn.net/qq_26222859/article/details/51473278","tags":[]},{"title":"react的学习网址","date":"2016-12-06T01:24:23.000Z","path":"2016/12/06/react的学习网址/","text":"react的学习网址(软件ATOM)http://www.css88.com/react/docs/glossary.htmlhttps://github.com/lengziyu/learn-webpackhttps://github.com/lengziyu/learn-react","tags":[]},{"title":"react的基本理解","date":"2016-12-05T09:42:15.000Z","path":"2016/12/05/react/","text":"react React是一个用于构建用户界面的JavaScript库，而不是一个MVC框架，但可以使用React作为MVC架构的View层轻易的在已有项目中使用。 React 是一个用于构建用户界面的 JAVASCRIPT 库。 React主要用于构建UI，很人多认为 React 是 MVC 中的 V（视图）。 React 起源于 Facebook 的内部项目，用来架设 Instagram 的网站，并于 2013 年 5 月开源。 React 拥有较高的性能，代码逻辑非常简单，越来越多的人已开始关注和使用它。(虚拟的dom操作)eg:innerHtml dom操作 获取react webpack(打包) 我们可以通过以下地址来获取React进行使用： https://atom.io/ https://facebook.github.io/react/downloads.html JSX简介:HTML 语言直接写在 JavaScript 语言之中，不加任何引号，这就是 JSX 的语法，它允许 HTML 与 JavaScript 的混写 JSX的好处 使用JSX语法来封装组件有什么好处： 熟悉的代码 更加语义化 更加抽象且直观 三大框架：angular.js react.js vue.js 代码注解 虚拟化操作&lt;script type=&quot;text/javascript&quot; src=&quot;js/react-dom.js&quot;&gt;&lt;/script&gt; jsx转化为插件&lt;script type=&quot;text/javascript&quot; src=&quot;js/browser.min.js&quot;&gt;&lt;/script&gt; 实例1:再id为test的div标签添加h1标签,内容显示hello Susanvar name = &quot;Susan&quot;; ReactDOM.render(//render在nodejs阶段出现 &lt;h1&gt;hello {name}!!&lt;/h1&gt;,//name是变量 document.getElementById(&quot;test&quot;)//这里不能加逗号 ); 实例2:数组的循环输出注意点: 循环出来的一定要return出来 render里面是有两个参数,记得第二个后面不能加分号 var arr = [‘a1’,’a2’,’a3’]; ReactDOM.render( &lt;ul&gt; { arr.map(function(value){//类似for循环 return &lt;li&gt;{value}&lt;/li&gt; }) } &lt;/ul&gt;, document.getElementById(&apos;test&apos;) ) 实例3:var Test = React.createClass( { render:function(){ return &lt;ul&gt; { React.Children.map(this.props.children,function(child){ return child; }) } &lt;/ul&gt; } } ); 实例4:可以是多个组件,createClass是创建组件,(props是获取所有东西，包括属性)注意点: React.Children获取组件中的所有子级,组件的变量名要大写 ReactDOM是要输出出来的，React是不用输出出来的 实例的解析: 创建组件(React.createClass) 里面的传参是对象 传参数（用this.props.name) this-&gt;指的是对应的属性名 123456789101112 var name = &quot;world&quot;;var Test = React.createClass(&#123;render:function()&#123; var str = &apos;&apos;; for(var i = 0;i&lt;5;i++)&#123; str += i+&quot;,&quot;; &#125; return &lt;h1&gt;hello &#123;this.props.name&#125;&#123;str&#125;&lt;/h1&gt; //对调用的对象,获取该对象的属性,this指的是Test标签&#125;&#125;) ReactDOM.render(&lt;Test name=&apos;React&apos;&gt;,document.querySelector(&quot;#test1&quot;));ReactDOM.render(&lt;Test name=&apos;Susan&apos;/&gt;,document.querySelector(&quot;#test2&quot;)); 实例5:propTypes 传值类型规范设置,getDefaultProps 设置默认值解析： React.PropTypes.string.isRequired 是告诉变量是类型字符串，isRequired是一定要传参(不能非空) getDefaultProps是定义默认传得参数值 123456789101112131415161718192021 var Test = React.createClass(&#123; getDefaultProps:function()&#123; return &#123;name:&quot;world&quot;&#125; &#125;, propTypes:&#123; name:React.PropTypes.string.isRequired &#125;, render:function()&#123; return &lt;h1&gt;&#123;this.props.name&#125;&lt;/h1&gt; &#125; &#125;) ReactDOM.render(&lt;Test/&gt;,document.getElementById(&quot;test&quot;)); ``` ### 实例6:显示与隐藏#### 注意点: 1. return出来的是多个标签.如果有多个标签就,一定要添加父级标签 2. onClick一定要要大写C 3. ref类似定义id 4. 改变按钮的value值,用setState来设置value值(会重新赋值) var Test = React.createClass({ getInitialState:function(){//初始化 return { bol:true } }, show:function(e){//事件 if(this.state.bol){ this.refs.d1.style.display = &quot;none&quot;; }else{ this.refs.d1.style.display = &quot;block&quot;; } &lt;!-- this.state.bol = !this.state.bol; //是类似innnerHTML,要重新赋值才能显示，这里只是显示第一次--&gt; this.setState({bol:!this.state.bol}) }, render:function(){ return &lt;div&gt; &lt;input onClick={this.show} type=&quot;button&quot; value={this.state.bol?&quot;显示&quot;:&quot;隐藏&quot;} /&gt; &lt;div ref=&apos;d1&apos;&gt;这是div&lt;/div&gt; &lt;/div&gt; } }) ReactDOM.render(&lt;Test/&gt;,document.querySelector(&quot;#test&quot;)); 1234567 ### 实例7:类似双向绑定的实例,再input输入的内容下面div也会跟着显示相对应的内容#### 解析:1. this.setState(&#123;test:value&#125;)是重写赋值2. target是委托事件 e.target是获取到input标签3. value=&#123;this.state.test&#125;是重写显示input里面的内容 ,this.state.test是显示默认值（getInitialState）属性里面的 var Test = React.createClass({ getInitialState:function(){ return { test:&quot;hello Susan&quot; } }, change:function(e){ var value = e.target.value; this.setState({test:value}) }, render:function(){ return &lt;div&gt; &lt;input onChange={this.change} type=&quot;text&quot; value={this.state.test}/&gt; &lt;div ref=&apos;d1&apos;&gt;{this.state.test}&lt;/div&gt; &lt;/div&gt; } }) ReactDOM.render(&lt;Test/&gt;,document.querySelector(&quot;#test&quot;)); 12345678910111213141516 # 组件的生命周期### 初始化 1. getDefaultProps:设置默认属性2. getinitialState:设置初始的状态3. componentWillMount:组件即将被装载（元素准备操作完毕）4. render:渲染,类似innerHTML5. componentDidMount:组件已经被装载,只会在第一个组件的时候触发 ### 运行中 1. shouldComponentUpdate:在接收到新的props或者state,将要渲染之前调用.(当要准备触发之前)2. componentWillUpdate:render触发之前,更新3. render:渲染4. componentDidUpdate: 在渲染完成之后触发 var Test = React.createClass({ componentWillMount:function(){ var input = document.querySelector(&quot;#i1&quot;); console.log(&quot;组件即将被装载&quot;,input) }, componentDidMount:function(){ var input = document.querySelector(&quot;#i1&quot;); console.log(&quot;组件已经被装载&quot;,input) }, componentWillUpdate:function(){ console.log(&quot;内容即将改变&quot;,this.state.test) }, componentDidUpdate:function(){ console.log(&quot;内容已经改变&quot;,this.state.test) }, shouldComponentUpdate:function(){ console.log(&quot;获取新的参数&quot;) return true; }, getInitialState:function(){ return { test:&quot;hello Susan&quot; } }, change:function(e){ var value = e.target.value; this.setState({test:value}) }, render:function(){ return &lt;div&gt; &lt;input id=&quot;i1&quot; onChange={this.change} type=&quot;text&quot; value={this.state.test}/&gt; &lt;div ref=&apos;d1&apos;&gt;{this.state.test}&lt;/div&gt; &lt;/div&gt; } }) ReactDOM.render(&lt;Test/&gt;,document.querySelector(&quot;#test&quot;)); 12345 # ajax的显示数据### 方法二:get属性可以换成另外一种写法 $.get(&quot;/get&quot;,(data)=&gt;{ this.setState(data) },&quot;json&quot;) 12 再index.html里面的js代码 var Test = React.createClass({ getInitialState:function(){ return { name:&quot;&quot;, age:&quot;&quot; } }, get:function(){ var _this = this; $.ajax({ type:&quot;get&quot;, url:&quot;/get&quot;, dataType:&quot;json&quot;, success:function(data) { _this.setState(data) } }) }, render:function(){ return &lt;div&gt; &lt;button onClick={this.get}&gt;获取数据&lt;/button&gt; &lt;h1&gt;{this.state.name}&lt;/h1&gt; &lt;p&gt;{this.state.age}&lt;/p&gt; &lt;/div&gt; } }) ReactDOM.render(&lt;Test/&gt;,document.querySelector(&quot;#test&quot;)); 1再创建node_users.js文件,写一下文件 var express = require(&quot;express&quot;);//加载express文件 var app = express(); app.use(express.static(&apos;./&apos;)) //处理前端的请求 app.get(&quot;/get&quot;, function (req,res) { res.send(&apos;{&quot;name&quot;:&quot;abc&quot;,&quot;age&quot;:&quot;18&quot;}&apos;); }); app.listen(8080); 12 ## 封装tab切换组件 var Tab = React.createClass({ componentDidMount:function(){//加载完毕的属性名 var inputs = document.querySelectorAll(&quot;input&quot;); var p = test.querySelectorAll(&quot;p&quot;); for(var i = 0;i &lt; inputs.length;i++){ inputs[i].index = i;//给每个input添加下标 } //添加默认事件 inputs[0].className = &quot;active&quot;; p[0].className = &quot;show&quot;; }, show:function(e){ var inputAll = document.querySelectorAll(&quot;input&quot;); var p = test.querySelectorAll(&quot;p&quot;); var input = e.target;//是委托事件,可以再下面点击按钮获取当前点击的按钮 var index = input.index; for(var i = 0;i &lt; p.length;i++){ p[i].className = &quot;&quot;; inputAll[i].className = &quot;&quot;; } p[index].className = &quot;show&quot;; input.className = &quot;active&quot;; }, render:function(){//这里的标签不能添加class类 return &lt;div&gt; &lt;input type=&quot;button&quot; index=&quot;1&quot; value=&quot;按钮1&quot; onClick={this.show}/&gt; &lt;input type=&quot;button&quot; value=&quot;按钮2&quot; onClick={this.show}/&gt; &lt;input type=&quot;button&quot; value=&quot;按钮3&quot; onClick={this.show}/&gt; &lt;input type=&quot;button&quot; value=&quot;按钮4&quot; onClick={this.show}/&gt;&lt;br/&gt; &lt;p class=&quot;show&quot;&gt;1&lt;/p&gt; &lt;p&gt;2&lt;/p&gt; &lt;p&gt;3&lt;/p&gt; &lt;p&gt;4&lt;/p&gt; &lt;/div&gt; } }) ReactDOM.render(&lt;Tab/&gt;,document.querySelector(&quot;#test&quot;)); ```","tags":[]},{"title":"html单位","date":"2016-12-02T02:09:59.000Z","path":"2016/12/02/html单位/","text":"html单位http://blog.csdn.net/u010408889/article/details/47781297 px to em:Example: 12px / 16px = .75em px to %:Example: 12px / 16px * 100 = 75% px to pt:Example: 16px * 72 (72 points = 1 inch) / 96 (96 pixels per inch in Windows, 72 in Mac) = 12pt em to px:Example: .75em * 16px = 12px em to %:Example: .75em * 100 = 75% % to px:Example: 75 * 16px / 100 = 12px % to em:Example: 75 / 100 = .75em pt to px:Example: 12pt * 96ppi / 72ppi = 16px","tags":[]},{"title":"html里在嵌套html的方法","date":"2016-12-02T01:49:17.000Z","path":"2016/12/02/html嵌套html/","text":"html里在嵌套htmlIFRAME参考地址:http://www.w3school.com.cn/tags/tag_frame.asp 这标记只适用於 IE。 它的作用是在一页网页中间插入一个框窗以显示另一个文件。它是 一个围堵标记，但围着的字句只有在浏览器不支援 iframe 标记时才会显示，如&lt;noframes&gt; 一样，可以放些提醒字句之类。通常 iframe 配合一个辨认浏览器的 Java Script 会较好，若 JavaScript 认出该浏览器并非 Internet Explorer 便会切换至另一版本。 iframe的参数设定如下： 例子： 1&lt;iframe src=&quot;iframe.html&quot; name=&quot;test&quot; align=&quot;MIDDLE&quot; width=&quot;300&quot; height=&quot;100&quot; marginwidth=&quot;1&quot; marginheight=&quot;1&quot; frameborder=&quot;1&quot; scrolling=&quot;Yes&quot;&gt; src=”iframe.html” 欲显示於此框窗的文件来源除档案名称，必要加上相对或绝对路径。 name=”test” 此框窗名称，这是连结标记的 target 参数所需要的， align=”MIDDLE” 可选值为 left, right, top, middle, bottom，作用不大width=”300” height=”100”框窗的宽及长，以 pixels 为单位。 marginwidth=”1” marginheight=”1”该插入的文件与框边所保留的空间。 frameborder=”1”使用 1 表示显示边框， 0 则不显示。（可以是 yes 或 no） scrolling=”Yes”使用 Yes 表示容许卷动（内定）， No 则不容许卷动。例子： 原始码 123 &lt;center&gt; &lt;iframe src=&quot;iframe.html&quot; name=&quot;test&quot; align=&quot;MIDDLE&quot; width=&quot;300&quot; height=&quot;100&quot; marginwidth=&quot;5&quot; marginheight=&quot;5&quot; frameborder=&quot;1&quot;&gt; 很抱歉，阁下使用的浏览器并不支援 IFrame，不能正常浏览我的网页。&lt;/iframe&gt; &lt;/center&gt;","tags":[]},{"title":"ECMAScript的入门","date":"2016-11-25T09:57:02.000Z","path":"2016/11/25/ECMAScript的概述/","text":"ECMAScript简介 它的目标，是使得JavaScript语言可以用来编写复杂的大型应用程序，成为企业级开发语言 Babel 是一个广泛使用的转码器，可以将ES6代码转为ES5代码，从而在现有环境执行。 ECMAScript的概述除了正常运行模式，ECMAscript 5添加了第二种运行模式：”严格模式”（strict mode）。顾名思义，这种模式使得Javascript在更严格的条件下运行。 设立”严格模式”的目的，主要有以下几个： 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为; 消除代码运行的一些不安全之处，保证代码运行的安全； 提高编译器效率，增加运行速度； 为未来新版本的Javascript做好铺垫。 “严格模式”体现了Javascript更合理、更安全、更严谨的发展方向，包括IE 10在内的主流浏览器，都已经支持它，许多大项目已经开始全面拥抱它。另一方面，同样的代码，在”严格模式”中，可能会有不一样的运行结果；一些在”正常模式”下可以运行的语句，在”严格模式”下将不能运行。掌握这些内容，有助于更细致深入地理解Javascript，让你变成一个更好的程序员。 严格模式是如何使用 将”use strict”放在脚本文件的第一行，则整个脚本都将以”严格模式”运行。如果这行语句不在第一行，则无效，整个脚本以”正常模式”运行。如果不同模式的代码文件合并成一个文件，这一点需要特别注意。(放在函数里面也要放再最顶部) eval,就是将字符串转换为可执行的代码语句 12345&quot;use strict&quot;;var i = 1;var str = &apos;var i = 5&apos;;eval(str);console.log(i);//1 2. 禁止this关键字指向全局对象(即指向window) setTimeout就没有这种效果 1234567891011121314function f()&#123;&quot;use strict&quot;;//只是再函数,这一部分才是严格模式// console.log(this);//objfunction time()&#123; this.name = &quot;obj&quot;;//会报错,this是undefined console.log(this);//本来是window,再严格模式下是undefined&#125;// time.call(&#123;&#125;);//obj time();//undefind&#125;var obj = &#123;&#125;;obj.f = f;obj.f();//object// f();//undefind 3. 全局变量显式声明 12345678910// function show()&#123;// num = 1;//相当于num是全局变量// &#125;// console.log(num);//1 &quot;use strict&quot;;function show()&#123; num = 1;&#125;console.log(num);//是直接报错 Babel的转码这意味着，如果项目要运行，全局环境必须有Babel，也就是说项目产生了对环境的依赖。另一方面，这样做也无法支持不同项目使用不同版本的Babel。 怎么将es6转成es5要先安装babel1. 安装全局的babel-cli ($ sudo cnpm install -g babel-cli) 2. 告诉要转换以后的格式 ($ sudo cnpm install babel-preset-es2015) 3. 创建配置文件 (.babelrc普通文件) 123456 Babel的配置文件是 .babelrc ，存放在项目的根目录下。使用Babel的第一步，就是配置这个文件。该文件用来设置转码规则和插件，基本格式如下&#123; &quot;presets&quot;: [&quot;es2015&quot;], &quot;plugins&quot;: []&#125; babel是怎么运行 转码结果输出到标准输出 $ babel example.js 转码结果写入一个文件(–out-file 或 -o 参数指定输出文件) `babel example.js --out-file compiled.js`或者是`babel example.js -o compiled.js` 整个目录转码(–out-dir 或 -d 参数指定输出目录) $ babel src --out-dir lib或者是$ babel src -d lib ES6新特性在Babel下的兼容性列表ES6特性 兼容性 箭头函数 支持 类的声明和继承 部分支持，IE8不支持 增强的对象字面量 支持 字符串模板 支持 解构 支持，但注意使用方式 参数默认值，不定参数，拓展参数 支持 let与const 支持 for of IE不支持 iterator, generator 不支持 模块 module、Proxies、Symbol 不支持 Map，Set 和 WeakMap，WeakSet 不支持 Promises、Math，Number，String，Object 的新API不支持 export &amp; import 支持 生成器函数 不支持 数组拷贝 支持 es6新增的命令(let_const) ES6新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。 123456 &#123; let a = 10;//a只属于这个块&#123;&#125;里面,外面不可以用 var b = 1;&#125; console.log(a);//直接报错 console.log(b);//1 for循环的计数器，就很合适使用let命令。 (tab切换) 12345678910111213141516171819202122 var arr = []; for (let i = 0; i &lt; 10; i++) &#123; arr[i] = function () &#123; console.log(i) &#125;; &#125; arr[6]();//6 //不同:(上面代码中，变量i是var声明的，在全局范围内都有效。所以每一次循环，新的i值都会覆盖旧值，导致最后输出的是最后一轮的i的值。) var a = []; for (var i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;; &#125; a[6](); // 10 ``` * 不存在变量提升 var foo = 2; let bar = 2; var num = 3; function show(){ console.log(num);//undefined var num = 2; } show(); 123* 暂时性死区下面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。 var tmp = 123; if (true) { // tmp = ‘abc’;//报错 let tmp; tmp = &apos;abc&apos;; console.log(tmp);//abc } console.log(tmp); 12 * 不允许重复声明 let不允许在相同作用域内，重复声明同一个变量。 (function() { let a = 10; var a = 1; console.log(a); })() 12 * ES6的块级作用域(let实际上为JavaScript新增了块级作用域。) function f1() { let n = 5; if (true) { let n = 10; } console.log(n); } f1() 1下面代码中，函数f执行后，输出结果为undefined，原因在于变量提升，导致内层的tmp变量覆盖了外层的tmp变量。 var tmp = new Date(); function f() { console.log(tmp); if (false) { var tmp = &quot;hello world&quot;; } } f(); // undefined 12内层作用域可以定义外层作用域的同名变量。 {{{{ {let insane = 'Hello World'} console.log(insane); // 报错 }}}}; 1* const命令(const声明一个只读的常量。一旦声明，常量的值就不能改变。) const PI = 3.1415; console.log(PI); 123 ## ES6结构赋值1. 数组的解构赋值(ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构) //实例1 let [a, b, c] = [1, 2, 3]; console.log(a) // 1 console.log(b) // 2 console.log(c) // 3 //实例2 ...var2表示其余的数值的数组 let [val1, ...var2] = [1, 2, 3, 4]; //...var2是数组 console.log(var1)//1 console.log(var2)//[2,3,4] 12. 对象的解构赋值(解构不仅可以用于数组，还可以用于对象) var obj = { name:&quot;obj&quot;, arr:[1,2,3,4], json:{ name:&quot;json&quot;, } } var {name,arr,json} = obj; console.log(name,arr,json); 123 ## ES6函数\u0010扩展* 函数参数的默认值( 在ES6之前，不能直接为函数的参数指定默认值，只能采用变通的方法。) function show(a,b){ var b = b||0;//给b默认值 console.log(a+b); } show(4);//4 1* ES6允许为函数的参数设置默认值，即直接写在参数定义的后面。 function show(a=2,b=1){//给参数a和b一个默认值 console.log(a+b); } show(5);//6 //解析: function show() { var a = arguments.length &gt; 0 &amp;&amp; arguments[0] !== undefined ? arguments[0] : 2; var b = arguments.length &gt; 1 &amp;&amp; arguments[1] !== undefined ? arguments[1] : 1; //给参数a和b一个默认值 console.log(a + b); } show(5); //6 a=5,b=1 12 * 与解构赋值默认值结合使用(参数默认值可以与解构赋值的默认值，结合起来使用。) function show([a,b,c]){ console.log(a+b+c); } var arr = [1,2,3]; show(arr);//6 1* 作用域(一个需要注意的地方是，如果参数默认值是一个变量，则该变量所处的作用域，与其他变量的作用域规则是一样的，即先是当前函数的作用域，然后才是全局作用域。) //实例1 var x = 1; function f(x, y = x) { console.log(y); } f(2)//2 //实例2 let x = 1; function f(y = x) { let x = 2; console.log(y);//1 } f() 1234567891011121314151617181920212223242526272829303132333435 * rest参数ES6引入rest参数（形式为“...变量名”），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest参数搭配的变量是一个数组，该变量将多余的参数放入数组中。 var arr = [78,789,45]; // ES5的写法 console.log(Math.max.apply(null,arr)); // ES6的写法 console.log(Math.max(...arr));//...arr将数组全部抽出来 //解析ES6为ES5 var arr = [78, 789, 45]; console.log(Math.max.apply(Math, arr)); * ES5的合并数组 var arr = [1,2,3]; var arr2 = [4,5,6]; var arr3 = [7,8,9]; var all = arr.concat(arr2,arr3); console.log(all);//[1,2,3,4,5,6,7,8,9]; * ES6的合并数组 var arr = [1,2,3]; var arr2 = [4,5,6]; var arr3 = [7,8,9] var all = [...arr,...arr2,...arr3]; console.log(all);//1,2,3,4,5,6,7,8,9 * 箭头函数(ES6允许使用“箭头”（=&gt;）定义函数。) var a = 5; var fn = a =&gt; a;//第一个a是参数,第二个是return出来的\u0010块 console.log(fn(a));//5 //解析得到下面这段代码 &quot;use strict&quot;; var a = 5; var fn = function fn(a) { return a; }; console.log(fn(a)); 1234567&lt;mark&gt;注意点:箭头函数有几个使用注意点。&lt;/mark&gt;1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。 //实例: var obj = { show:function(){ console.log(this);//obj // setTimeout(function(){ // console.log(this);//window // }) setTimeout(()=&gt;{ console.log(this);//不是当前的setTimeout,就向上找,那这边就是往上找是obj }) } } 1* for of循环函数 function Person(){ var sum = 0; for(var value of arguments){ sum += value;//注意点,value是表示数组的没事实际值 } console.log(sum); } Person(23,45,78,36);//sum = 23+45+78+36 123 ## Class* class基本语法(ES5) function Person(name){ this.name = name; } Person.prototype.show = function(){ console.log(this.name); } var obj = new Person(&quot;abc&quot;); obj.show(); function Son(){ this.age = arguments[1]; Person.apply(this,arguments); } Son.prototype = new Person(); //Son.prototype = Person.prototype; var s = new Son(&quot;son&quot;,12); s.show(); console.log(s.age); 12 * Class的继承(Class之间可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多) class Person{//省略了function //构造方法 constructor(name){ this.name = name; } //原型方法 show(){ console.log(this.name); } } var person = new Person(&quot;es6&quot;); person.show(); class Son extends Person{ constructor(name,age){ super(name); this.age = age; this.name = &quot;abc&quot;; } } var son = new Son(&quot;nson&quot;); son.show();//abc ``` 模块化(没有浏览器支持)export var a = 5;//a.js import a from &apos;a.js&apos;","tags":[]},{"title":"node.js的安装命令","date":"2016-11-22T04:01:32.000Z","path":"2016/11/22/安装的命令行/","text":"node.js2buffer js语言自身只有字符串数据类型,没有二进制类型 buffer:缓存器区,暂时存放在内存里的一段数据 由一个八位字节一个元素组成的数组,单位用16进制表示,取值范围0-255(00-ff) 创建buffer对象的方法 12345678910111213141516 var buffer = new Buffer(6);//buffer.fill(144);//填充console.log(buffer);//2.通过数组var buf1 = new Buffer([255,100,1,0xaa]);console.log(buf1);//3.通过字符串var buf2 = new Buffer(&quot;str&quot;);console.log(buf2);console.log(buf2.toString());var buf3 = new Buffer([ 0x73, 0x74, 0x72]);console.log(buf3.toString()); fs工具包 异步模式(有回调函数) 下面的代码不需要等 同步模式(没有回调函数) 下面的代码要等 12345678910111213 //异步 fs.readFile(&quot;test/abc.txt&quot;,function(err,data)&#123; if(err)&#123; console.log(err); return; &#125; console.log(data.toString());&#125;);console.log(1);//同步var con = fs.readFileSync(&quot;test/abc.txt&quot;);console.log(con.toString());console.log(1); 注意点：下面的代码类似异步，但是js都是从上往下执行12345678 //不是异步,js是从上往下读function show(a,b,cb)&#123; console.log(a+b); cb();&#125;show(5,56,function()&#123; console.log(1);&#125;) 文件操作和目录操作 写入内容writeFile(url,data,{flag:w},fn(err)) 1234 fs.writeFile(&quot;test/abc1.txt&quot;,&quot;写入的东西&quot;, &#123;flag:&quot;w&quot;&#125;,function(err)&#123; if(err)&#123;console.log(&quot;写入失败&quot;+err);return;&#125; console.log(&quot;写入成功&quot;);&#125;); 创建文件mkdir(filename,0777,fn(err)) //0777是读与写 0555是只读 1234fs.mkdir(&quot;test/abc&quot;,0777,function(err)&#123; if(err)&#123;console.log(&quot;创建失败&quot;);return;&#125; console.log(&quot;创建成功&quot;);&#125;) 读取目录所有文件readdir(url,fn(err,files)) 123fs.readdir(&quot;./&quot;,function(err,files)&#123; console.log(files);&#125;) 判断文件是否存在 fs.existsSync(urlstr) 获取文件或文件夹的详细信息 var stat = fs.lstatSync(urlstr); 如果是文件返回true否则false var isfile = stat.isFile(); 读写流 stream,主要是用在大数据处理. var rs = createReadStream创建一个可读流 var ws = createWriteStream创建一个可写流 pipe该方法从可读流中拉取所有数据，并写入到所提供的目标。 rs.on(‘data’,fn(data))每读64K或读完触发的时间 rs.on(“end”) 1234var fs = require(&quot;fs&quot;);var rs = fs.createReadStream(&quot;GitHub Desktop 220.zip&quot;);var ws = fs.createWriteStream(&quot;test/a.zip&quot;);rs.pipe(ws); 模块目前，通行的Javascript模块规范共有两种：CMD和AMD。 AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。 CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。 这些规范的目的都是为了 JavaScript 的模块化开发，特别是在浏览器端的。目前这些规范的实现都能达成浏览器端模块化开发的目的。 AMD和CMD的区别 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible. CMD 推崇依赖就近，AMD 推崇依赖前置。 12345678910111213141516 define(function(require, exports, module) &#123;var a = require(&apos;./a&apos;)a.doSomething()// 此处略去 100 行var b = require(&apos;./b&apos;) // 依赖可以就近书写b.doSomething()// ... &#125;)// AMD 默认推荐的是define([&apos;./a&apos;, &apos;./b&apos;], function(a, b) &#123; // 依赖必须一开始就写好a.doSomething()// 此处略去 100 行b.doSomething()...&#125;) 虽然 AMD 也支持 CMD 的写法，同时还支持将 require 作为依赖项传递，但 RequireJS 的作者默认是最喜欢上面的写法，也是官方文档里默认的模块定义写法。 所有模块都通过 define 来定义 `define(function(require, exports, module) {}) 通过 require 引入依赖 var $ = require(&#39;jquery&#39;); var test= require(&#39;./test); 通过 exports 对外提供接口 exports.test = test 或者通过 module.exports 提供整个接口 module.exports = ... requiresjs的使用在HTML中，添加这样的 标签: 通常使用requirejs的话，我们只需要导入requirejs即可，不需要显式导入其它的js库，因为这个工作会交给requirejs来做。 属性 data-main 是告诉requirejs：你下载完以后，马上去载入真正的入口文件。它一般用来对requirejs进行配置，并且载入真正的程序模块。 在config.js中配置requirejs config.js 中通常用来做两件事： 配置requirejs 比如项目中用到哪些模块，文件路径是什么 载入程序主模块 12345678910 requirejs.config(&#123; baseUrl: &apos;/js&apos;, paths: &#123; jq: &apos;jquery.1.12.1&apos; &#125;&#125;);requirejs([&apos;jq&apos;], function($) &#123; $(&quot;div&quot;).css();&#125;); config里面文件属性的介绍在 paths 中，我们声明了一个名为 app 的模块，以及它对应的js文件地址。在最理想的情况下， app.js 的内容，应该使用requirejs的方式来定义模块 define: 定义一个模块; 1234567891011 define([&quot;jquery&quot;,&quot;show&quot;], function($,show) &#123; return &#123; hello: function() &#123; show() alert(&quot;hello, app~&quot;); &#125; &#125;&#125;); ``` shim将某个依赖中的某个全局变量暴露给requirejs，当作这个模块本身的引用。 requirejs.config({ baseUrl: &apos;/public/js&apos;, paths: { hello: &apos;hello&apos; }, shim: { hello: { exports: &apos;hello&apos; } } }); //注意点: requirejs([&apos;hello&apos;], function(hello) { hello(); }); ``` 淘宝的镜像安装 sudo npm install cnpm -g config.js的配置文件baseUrl:是目录jquery:引入的文件不需要写后缀名jQuery.noConflict: 是多库共存 npm init(可以把一台电脑按装得node-module，一到另外一台电脑) 预处理语言 less sass styles gulp是什么gulp 是基于 Nodejs 的自动任务运行器，能自动化地完成文件的的测试、检查、合并、压缩、格式化、浏览器自动刷新、部署文件生成,并监听文件在改动后重复指定的这些步骤。 在实现上， gulp 借鉴了Unix操作系统的管道（pipe）思想，前一级的输出，直接变成后一级的输入，使得在操作上非常简单. 创建目录结构建立如下目录结构，gulp 作为我们的项目根目录。 安装的步骤 全局安装一遍 sudo cnpm install -g gulp 运行时注意查看命令行有没有错误信息，安装完成后，你可以使用下面的命令查看gulp的版本号以确保gulp已经被正确安装。 gulp -v 接着我们要进去到项目的根目录再安装一遍 sudo cnpm install gulp –save-dev 安装下面的gulp插件 我们将要使用Gulp插件来完成我们以下任务： less的编译（gulp-less） 自动添加css前缀（gulp-autoprefixer） 压缩css（gulp-minify-css） 压缩js代码（gulp-uglify） 打包文件 require(‘gulp-zip’); 开启服务器 自动刷新 启动浏览器require(‘gulp-webserver’); require(“amd-optimize”);AMD模块构建 require(‘gulp-concat’);合并JS gulp只有四个API：task，watch，src，和 dest task：这个API用来创建任务，在命令行下可以输入 gulp test 来执行test的任务。 watch：这个API用来监听任务。 src：这个API设置需要处理的文件的路径，可以是多个文件以数组的形式.scss]，也可以是正则表达式/*/.scss。[main.scss, vender dest：这个API设置生成文件的路径，一个任务可以有多个生成路径，一个可以输出未压缩的版本，另一个可以输出压缩后的版本。","tags":[]},{"title":"快捷键,ui框架地址","date":"2016-11-21T08:55:10.000Z","path":"2016/11/21/前端ui框架和快捷键网站/","text":"快捷键http://emmet.evget.com/#Syntax UI框架https://www.awesomes.cn/rank/ xmapp:ajax","tags":[]},{"title":"node.js的理解及使用","date":"2016-11-21T06:23:18.000Z","path":"2016/11/21/node/","text":"node.js什么是node(单线程) node是js语言的服务器运行环境（类似于php和apache） nodejs提供大量的工具库，使得javascirpt可以调用操作系统级别的api。 node采用谷歌的v8引擎（javascipt语言解释器），速度非常快跟js环境不一样，一个是运行在服务器，一个运行在客户端 node是一个基于事件驱动和异步io的服务器javascript环境 特别注意：一定要端口不一样，如果访问是80可以不写，其他的端口就一定要写上，一旦成功连接，服务器就会一直开着 还有一些基础：回调：异步编程的基本方法，采用后续函数传递的方式，把后续的处理函数作为参数进行执行同步和异步（阻塞非阻塞）：AJAX的时候说过 IO：input outputer输入 输出，对应的就是下单操作 单线程和多线程单线程按顺序执行，多线程可以同时执行 node怎么用 1.require(‘http’); 引入一个HTTP的模块 2.server = http.createServer(function(req,res)) 创建一个HTTP服务器 1234req:request请求对象res:response:响应对象res.writeres.end 3.server.listen(port,function)监听响应 123456789 var http = require(&quot;http&quot;);var server = http.createServer(function(req,res)&#123; res.write(&quot;响应内容&quot;); res.end(&quot;响应结束&quot;);//结束&#125;)server.listen(8080,function()&#123; console.log(&quot;开启服务器:http://localshost:8080&quot;);&#125;) node.js出现乱码，怎么做 req.url:’/‘,请求的地址 ‘/‘根目录 req.method: ‘GET’ 请求方式 发送 HTTP 头部 HTTP 状态值: 200 : OK 内容类型: text/html res.writeHead(200,{Content-Type:xxx}) http://tool.oschina.net/commons 1234567891011 //实例 var http = require(&apos;http&apos;);//引入一个HTTP的模块var server = http.createServer(function (req,res)&#123; res.writeHead(200,&#123;&quot;Content-Type&quot;:&quot;text/html;charset=utf-8&quot;&#125;); res.end(&quot;&lt;div&gt;div标签&lt;/div&gt;响应结束&quot;); &#125;)server.listen(8080,function()&#123; console.log(&apos;开启成功&apos;)&#125;); 引入自定义的模板 引入的是路径 引入的是文件夹名字 注意点：如果是引入自定义的文件。如果存在多个文件，调用的时候就需要在当前文件夹里面创建json文件,添加 “main”:”page.js”(表明调用的是那个js文件) 123456789//实例一：//var home = require(&quot;./home.js&quot;);//可以引入自己定义的模块,但是要在当前新建模块//home.show();//home.abc();//实例二:var test = require(&quot;test&quot;);//test.show();test.page(7,8);","tags":[]},{"title":"各大浏览器的默认间距","date":"2016-11-20T07:58:38.000Z","path":"2016/11/20/默认间距/","text":"默认的间距 标题h1-h6有自己默认的间距（margin）","tags":[]},{"title":"自适应布局的注意点","date":"2016-11-16T15:05:01.000Z","path":"2016/11/16/自适应/","text":"自适应的布局的注意点 em是根据自身的font-size的大小,自身没有就按照父级元素 要按照iphone5和iphone6的比例 文字是不可以用% 文字最小是12px,默认是16px","tags":[]},{"title":"微信开发","date":"2016-11-16T15:04:25.000Z","path":"2016/11/16/微信开发/","text":"微信开发 打开微信公众号:https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login 接口修改,下载wk_weixin.php 获取access_token(2个小时的有效期,所以要保存下来,过期再重新获取) 就可以获取用户基本信息 页面授权(还要修改域名) 1 第一步：用户同意授权，获取code(每次授权获取到一个code) 2 第二步：通过code换取网页授权access_token(用code获取只能用一次) 3 第三步：刷新access_token（如果需要） 4 第四步：拉取用户信息(需scope为 snsapi_userinfo) 访问的时候,参数不要添加https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid= wx6be246ea36fabbda&amp;secret= 92aa8f5547c7a9fa17a06386dd2ed271 创建数据库 数据库的创建,要先再存储与CDN服务(Storage),创建bucket(要绑定域名) 数据库与缓存服务-&gt;共享型MySQL-&gt;管理(添加数据) 新浪云创建数据库 12345678910111213141516171819202122// 连主库,旧版的数据库连接$db=mysql_connect(SAE_MYSQL_HOST_M.&apos;:&apos;.SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS);if ($db) &#123; // mysql_select_db(SAE_MYSQL_DB, $db); echo &apos;ok&apos;; // ... &#125;else&#123; echo &apos;error&apos;; &#125; //新版数据库连接//新浪云的数据库连接$conn=mysqli_connect(SAE_MYSQL_HOST_M.&apos;:&apos;.SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS,SAE_MYSQL_DB);``` ## 获取唯一\u0010票证access_token1. 获取信息列表,需要通过获取access_token,才能获取用户的信息列表 (公众平台开发者文档-&gt;获取接口调用凭据)2. https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=APPID&amp;secret=APPSECRET(修改appid和secret)3. 要注意有效时间(7200s),有效时间过期之后就要重新获取access_token,目前access_token的有效期通过返回的expire_in来传达## 用户管理1. 获取openid (公众平台开发者文档-&gt;获取用户基本信息(UnionID机制)) 就会输出用户的个人信息 { “subscribe”: 1, “openid”: “o6_bmjrPTlm6_2sgVt7hMZOPfL2M”, “nickname”: “Band”, “sex”: 1, “language”: “zh_CN”, “city”: “广州”, “province”: “广东”, “country”: “中国”, “headimgurl”: “http://wx.qlogo.cn/mmopen/g3MonUZtNHkdmzicIlibx6iaFqAc56vxLSUfpb6n5WKSYVY0ChQKkiaJSgQ1dZuTOgvLLrhJbERQQ4eMsv84eavHiaiceqxibJxCfHe/0“, “subscribe_time”: 1382694957, “unionid”: “ o6_bmasdasdsad6_2sgVt7hMZOPfL” “remark”: “”, “groupid”: 0}122. https://api.weixin.qq.com/cgi-bin/user/get?access_token=ACCESS_TOKEN(修改access_token,获取用户列表)3. 获取用户列表(公众平台开发者文档-&gt;获取用户列表)--&gt;也就是关注我的用户信息 { “total”:23000, “count”:10000, “data”:{ “openid”:[ “OPENID10001”, “OPENID10002”, …, “OPENID20000” ] }, “next_openid”:”OPENID20000” } ``` 网页授权注意点:code换取网页授权access_token,的有效时间是5分钟,要记录到数据库中,防止调失.他的更新时间较长 微信JS-SDK 微信的接口用法","tags":[]},{"title":"php的数组方法","date":"2016-11-16T15:04:12.000Z","path":"2016/11/16/php_arr/","text":"http://www.baidu.comconsole.log(111)[baidu]http://php.net/manual/zh/features.commandline.php 12345678910111213141516171819&lt;?php// 创建一个简单的数组$array = array(1, 2, 3, 4, 5);print_r($array);// 现在删除其中的所有元素，但保持数组本身不变:foreach ($array as $i =&gt; $value) &#123; unset($array[$i]);&#125;print_r($array);// 添加一个单元（注意新的键名是 5，而不是你可能以为的 0）$array[] = 6;print_r($array);// 重新索引：$array = array_values($array);$array[] = 7;print_r($array);?&gt; 结果1234567891011121314151617181920Array( [0] =&gt; 1 [1] =&gt; 2 [2] =&gt; 3 [3] =&gt; 4 [4] =&gt; 5)Array()Array( [5] =&gt; 6)Array( [0] =&gt; 6 [1] =&gt; 7) php的boolean是不区分大小写 特殊: $var1 = TRUE; $var2 = FALSE; echo $var1;//输出1 echo $var2;//不输出 in_array() 函数搜索数组中是否存在指定的值 array_search() 在数组中搜索键值 5，并返回它的键名（注意 “”） array_change_key_case($name,CASE_UPPER/CASE_LOWER) CASE_LOWER - 默认值。将数组的键转换为小写字母。 CASE_UPPER - 将数组的键转换为大写字母。 array_chunk(array,size,true/false) 函数把数组分割为新的数组块。 前两个参数是必须的,size:必需。整数值，规定每个新数组包含多少个元素。 第三个参数:true - 保留原始数组中的键名。false - 默认。每个结果数组使用从零开始的新数组索引。 array_column() 返回输入数组中某个单一列的值。 array_combine(keys,values);函数通过合并两个数组来创建一个新数组，其中的一个数组是键名，另一个数组的值为键值。 array_count_values(array) 函数用于统计数组中所有值出现的次数。 数组升降 sort() - 以升序对数组排 rsort() - 以降序对数组排序 asort() - 根据值，以升序对关联数组进行排序 ksort() - 根据键，以升序对关联数组进行排序 arsort() - 根据值，以降序对关联数组进行排序 krsort() - 根据键，以降序对关联数组进行排序 表单提交 input的类型radio的name是要一致的,如”gender”,性别的单选择,通过name和value 函数PHP函数之可变函数12345678class book &#123; function getName() &#123; return &apos;bookname&apos;; &#125; &#125; $func = &apos;getName&apos;; $book = new book(); echo $book-&gt;$func(); private的数据类型调用 1234567891011&lt;?php class Car &#123; private $name = &apos;汽车&apos;; public function getName() &#123; return $this-&gt;name; &#125; &#125; $car= new Car(); //new一个新的类 echo $car-&gt;getName(); ?&gt; 单引号是不能访问变量","tags":[]},{"title":"php的总结(需要注意的问题)","date":"2016-11-14T11:54:36.000Z","path":"2016/11/14/php的总结/","text":"总结 header(“Content-Type: text/html;charset=utf-8”); //PHP页面转UTF-8编码 global是不可以赋值的,声明$a为全局变量 内存溢出:指没用的东西占用内存—&gt;函数的静态变量就类似闭包,会占用内存 局部变量在函数退出时会被撤消，与局部变量不同，静态变量在函数退出时不会丢失值，并且再次调用函数时还能保留这个值; 在变量名前面加上 static 关键字就可以声明一个静态变量;(内存溢出:指没用的东西再占用内存) 继承中子类继承父类 : 父类的元素中,如果是 私有元素子类不可以继承,但是protected是可以访问(是特指内部访问,子类外部是不可以访问的) 类的3大特点:封装 继承 多态","tags":[]},{"title":"php中面向对象,增删改查的操作","date":"2016-11-10T13:29:02.000Z","path":"2016/11/10/php4(实例+sql实例)/","text":"一、面向对象OOP(Object-Oriented Programming）面向对象编程—&gt;(面试)OOP达到了软件工程的三个目标：重用性、灵活性和扩展性。 采用面向对象方法可以使系统各部分各司其职、各尽所能; 使其编程的代码更简洁、更易于维护，并且具有更强的可重用性。 类 (class) 日常环境由无数实体组成:植物,人群,交通工具,食物… 每个实体都由一组性质和行为来定义。 例如： 男人 可以定义有：身高,体重,是否帅，肤色等性质，并且定义有能赚钱，能下厨，能开车等行为。在OOP术语中，实体的性质和行为的具体定义称为类 对象 (object) 通过类创建出来的实体称为对象。 对象是系统中用来描述客观事物的一个实体。 它是构成系统的一个基本单位,数据与代码都被捆绑在一个实体中。一个对象由一组属性和对这组属性进行操作的一组行为组成。 二、 PHP的面向对象 定义类 class name {} 创建对象（实例化） $obj = new name(); 访问对象中的成员 $obj-&gt;attr; const常量 可以在类中定义常量，即不会在类中改变的值。对于从该类实例化的任何对象来说，常量值在这些对象的整个生命周期中都保持不变。 echo self::PI; //类内部访问 echo 类名::PI; //类外部访问 static静态属性与静态方法 使用static 关键字可以用来标识成员属性,也可以用来标识成员方法， &lt;mark&gt;静态的成员属于类所有，所以我们在静态方法里，不能使用$this 来引用 静态成员,建议使用 self 关键字来调用。&lt;/mark&gt; 总结:常量是不用加$,静态变量要用$ 123456789101112131415161718class Person &#123; //静态和常量内部方法用self:: 外部访问用类名Person::(类名::) const str = &quot;常量&quot;; static $name = &quot;静态&quot;; public $age = 10; function show()&#123; echo self::str.&quot;&lt;br&gt;&quot;; echo self::$name.&quot;&lt;br&gt;&quot;; echo $this-&gt;age.&quot;&lt;br&gt;&quot;;//this指向新建的对象 &#125; &#125; $person = new Person();// $person-&gt;show();// echo Person::$name;//外部访问常量和静态变量需要通过类名echo Person::str;echo $person-&gt;age;//调用属性是不用$ 三、构造函数和析构函数 构造函数 通常用来对成员属性进行初始化赋值 __construct($name,$age) 析构函数 与构造方法对应的就是析构方法，析构方法允许在销毁一个类之前执行的一些操作或完成一些功能，比如说关闭文件、释放结果集等。析构函数不能带有任何参数，其名称必须是 __destruct() 。当函数执行完毕,才调用构造函数 1234567891011121314151617class People&#123; function __construct($name,$age) &#123; $this-&gt;name=$name;//js:$this.name = $name; $this-&gt;age=$age; &#125; function show()&#123; echo &quot;姓名:$this-&gt;name&quot;.&quot;&lt;br&gt;年龄:$this-&gt;age&quot;; &#125; //等该对象所有操作完成是触发 function __destruct()&#123; echo &quot;完成&quot;;//调用函数完毕之后,执行 &#125;&#125;$obj = new People(&quot;abc&quot;,18);$obj-&gt;show(); 四、访问修饰符（作用域描述符）访问修饰符允许开发人员对类成员的访问进行限制,这是PHP5的新特性。 public (公共修饰符) 类的成员将没有访问限制，所有的外部成员都可以访问（读和写）这个类成员。 在属性或方法前面加上关键字public,或不加任何关键字，都可以声明一个公共属性或方法。 private (私有修饰符) 被定义为private的成员，对于同一个类里的所有成员是可见的，即没有访问限制；但对于该类的外部代码是不允许改变甚至读操作，对于该类的子类，也不能访问。 protected (保护修饰符) 被修饰为protected的成员不能被该类的外部代码访问。但是对于该类的直接子类有访问权限，可以进行属性、方法的读及写操作。 被子类继承的protected成员，在子类外部同样不能被访问 123456789101112131415161718192021222324252627282930313233class Privated&#123; public $name = &quot;susan&quot;; private $age = 17; protected $idCard = 456467892123456; function show()&#123; echo $this-&gt;name; echo $this-&gt;age; echo $this-&gt;idCard; &#125;&#125;$obj = new Privated();$obj-&gt;show();echo &quot;&lt;br&gt;&quot;;echo $obj-&gt;name;//public公开的外部也可以访问// echo $obj-&gt;age;//private私有的外部不可以访问// echo $obj-&gt;idCard;//protected受保护的外部不可访问//继承class Son extends Privated&#123; function show()&#123; echo $this-&gt;name.&quot;&lt;br&gt;&quot;; // echo $this-&gt;age;//继承了父级的private私有的外部不可以访问 echo $this-&gt;idCard.&quot;&lt;br&gt;&quot;; &#125;&#125;$son = new Son();echo $son-&gt;name.&quot;&lt;br&gt;&quot;;// echo $son-&gt;age;//继承了父级的private私有的外部不可以访问// echo $son-&gt;idCard;//继承了父级的protected私有的外部不可以访问$son-&gt;show(); 五、封装封装就是把对象的属性和行为结合成一个独立的相同单位，并尽可能隐蔽对象的内部细节 六、继承面向对象开发方法建立在继承概念的基础上，这种策略提高了代码的重用性。 在PHP中，类继承通过 extends 关键字实现; 继承自其他类的类称为子类（child class 或 subclass) 子类所继承的类称为父类( parent class) 或 基类 (base class) 七、多态对象的多态性是指在父类中定义的属性或行为被子类继承之后，可以具有不同的数据类型或表现出不同的行为。这使得同一个属性或行为在父类及其各个子类中具有不同的语义。 sql语句一、编程接口从PHP5开始，PHP向程序员提供了两种MySQL应用程序编程接口:一种是从PHP早期版本一直就有的mysql功能模块;另一种是从PHP5才开始有的mysqli接口; mysql功能模块不是PHP的一个集成组件。要想使用这个功能扩展模块，不管使用是哪一种操作系统，都必须在php.ini文件里启用这个扩展以确保PHP能够找到所有必要的DLL “php_mysqli”。 `phpinfo();//查看php.ini设置，包括路径` 二、数据库操作一般步骤 MySQL建立连接与选择要操作的数据库 进行增删改查操作 关闭连接 三、连接MySQL服务器用mysqli_connect或者new mysqli方法连接数据库 如果连接成功，这个函数将返回一个对象。否则将返回FALSE,并向Web服务器发送一条出错消息，如果不想让最终用户在他们的web浏览器里看到这样的出错消息，就必须在函数前面加上一个@字符。 设置获取数据库的数据编码格式 $conn-&gt;query(&apos;set names utf8&apos;); mysqli_query($conn,&apos;set names utf8&apos;); 四、执行SQL语句$result = mysqli_query($conn,$sql); $result = $conn-&gt;query($sql); 五、获取和显示数据 fetch_row() 将以一个普通数组的形式返回一条结果，它的各个字段需要以$row[n]的方式进行访问。 eg:$arr[0] fetch_array() 将以一个关联数组的形式返回一条结果，它的各个字段需要以$row[n]或$row[“colname”]的方式进行访问。 eg:$arr[&quot;id&quot;] fetch_assoc() 将以一个关联数组的形式返回一条结果记录，但它的各个字段只能以 $row[“colname”]的方式进行访问。 123while ($row = $result-&gt;fetch_assoc()) &#123; printf (&quot;%s (%s)\\n&quot;, $row[&quot;Name&quot;], $row[&quot;CountryCode&quot;]); &#125; fetch_object() 函数以一个对象的形式返回一条结果记录.它的各个字段需要以$row-&gt;colname的方式进行访问。 eg:$obj-&gt;name 这4个函数的共同点是：每次调用将自动返回下一条结果记录,但如果已经到达结果数据表的末尾，则返回FALSE。 mysqli_free_result(result) 提前释放某次查询结果 mysqli_num_rows($conn) 函数用于获取查询返回的记录数; mysqli_insert_id(conn) mysql_insert_id()函数用于获取INSERT 操作产生的 ID; mysqli_affected_rows (conn) 函数用于获取前一次 MySQL 操作所影响的记录数 ; 12345678910if (input[1].value==&quot;&quot;) &#123;return false;&#125;//是阻止表单的提交用return false;if (!$conn) &#123; //方法一: die(&quot;连接失败&quot;);//和下面的 //方法二: // echo &quot;连接失败&quot;; // exit;//终止代码执行&#125; ``` //数据库连接 参数1:地址 参数2:用户名/权限 参数3:密码 参数4:数据库名$conn = @mysqli_connect(“localhost”,”root”,””,”mySusan”); //设置PHP操作数据库的编码格式$conn-&gt;query(“set names utf8”); //数据库的增删改查$sql = “SELECT * FROM myWrite LIMIT {$count},{$num}”;//limit适合用于分页(参数1:从那个数字开始,参数2:是长度) //执行sql语句$result = $conn-&gt;query($sql); //逐条输出echo ““;while ($arr = $result-&gt;fetch_assoc()) { echo “ {$arr[‘id’]} {$arr[‘title’]} {$arr[‘content’]} “;}echo ““; 1234567891011121314# sql增删改查* insert into table (name,con) values (&apos;susan&apos;,&apos;this is a name&apos;)* delete from table where id &gt;= 3* update table set id = 2* select * from table where id = 2#### as的用法://计算tablename表格的id长度,并且改字段名为len&lt;mark&gt;SELECT COUNT(id) as len FROM tablename&lt;/mark&gt;## insert用法 &lt;?php$conn = @mysqli_connect(“localhost”,”root”,””,”html5”);if(!$conn) { die(“连接失败”);}$conn-&gt;query(“set names utf8”);$sql = “INSERT INTO user (username,pwd) VALUES(‘文章1’,’111111’)”;$conn-&gt;query($sql);if (mysqli_affected_rows($conn)&gt;0) { echo “添加成功:”.mysqli_insert_id($conn);}else{ echo “添加失败”;}?&gt;12## update用法 &lt;?php$conn = @mysqli_connect(“localhost”,”root”,””,”html5”);if(!$conn) { die(“连接失败”);}$conn-&gt;query(“set names utf8”);$sql = “UPDATE user SET username=’中文’ WHERE pwd=123”;$conn-&gt;query($sql);if (mysqli_affected_rows($conn)&gt;0) { echo “添加成功:”.mysqli_affected_rows($conn);}else{ echo “添加失败”;}?&gt;12## delete用法 $conn = @mysqli_connect(“localhost”,”root”,””,”html5”);if(!$conn) { die(“连接失败”);}$conn-&gt;query(“set names utf8”);$sql = “DELETE FROM user WHERE id=3”;//不加where条件语句就会把整个表的数据都删了$conn-&gt;query($sql);if (mysqli_affected_rows($conn)&gt;0) { echo “删除成功:”.mysqli_affected_rows($conn);}else{ echo “删除失败”;}1234# 实例注册和登录## 注册 //静态界面 用户名: 密码: 确认密码: var input = document.querySelectorAll(\"input\"); input[3].onclick = function(){ if (input[1].value==\"\") {return false;} if (input[1].value!=input[2].value) { alert(\"两次输入的密码不一致\"); return false;//阻止提交 } } //php后台交互&lt;?php $username = $_POST[“username”]; $pwd = md5($_POST[“pwd”]);//md5加密 //数据库连接 $conn = @mysqli_connect(“localhost”,”root”,””,”mySusan”); //设置数据库的规格 $conn-&gt;query(“set names utf8”); //sql语句 $sql = “SELECT * FROM userT WHERE username=’{$username}’”; //执行sql语句 $conn-&gt;query($sql); if (mysqli_affected_rows($conn)&gt;0) { echo “用户名已注册”; exit; } //添加到数据库 $sql = “INSERT INTO userT (username,pwd) VALUES (‘{$username}’,’{$pwd}’)”; $conn-&gt;query($sql); if (mysqli_affected_rows($conn)&gt;0) { echo “注册成功”; }else{ echo “注册失败”; }?&gt; 12## 登录 //静态界面 用户名: 密码: //php后台交互&lt;?phpinclude_once(“sqlSina.php”); $username = $_POST[“name”];$txt = $_POST[“text”]; $conn = mysqli_connect(“localhost”,”root”,””,”sina”);$conn-&gt;query(“set names utf8”);//判断数据是否已经存在该用户名$sql = “SELECT * FROM user WHERE username=’{$username}’”;$result = $conn-&gt;query($sql);if (mysqli_affected_rows($conn)&gt;0) { echo “用户名已经注册,请重新输入用户名”; exit;//终止程序} //是插入信息$sql=”INSERT INTO user (username,con) VALUES (‘{$username}’,’{$txt}’)”;$conn-&gt;query($sql);if (mysqli_affected_rows($conn)&gt;0) {}else{ echo “添加失败”;} //分页$num = 10;$page = 1;$count = ($num-1)$page;$limit = “SELECT FROM user LIMIT {$count},{$num}”;$lResult=$conn-&gt;query($limit);$i = 0;while ($arr = $lResult-&gt;fetch_assoc()) { $i+=1; if ($i%5==0) { echo “","tags":[]},{"title":"php上传文件,数组的一些方法","date":"2016-11-09T09:56:26.000Z","path":"2016/11/09/php3(sql:array:string方法)/","text":"一、文件上传的相关配置 表单设置要进行文件的上传，需要对form表单进行特殊设置; 设定表单数据的提交方式为POST 设定enctype属性值为: multipart/form-data 为了避免用户等待许久之后才发现上传文件太大，可以在表单中添加MAX_FILE_SIZE隐藏域,通过设置其value值可以限制上传文件的大小; PHP设置 phpinfo();输出PHP设置信息 file_uploads是否允许通过HTTP上传文件，默认为ON upload_max_filesize允许上传文件大小的最大值，默认为2M，此指令必须小于post_max_size; upload_tmp_dir指定上传文件的临时存放路径，这个目录对于拥有此服务器进程的用户必须是可写的;如果未指定则使用系统默认值; post_max_size控制POST方式提交数据php所能够接收的最大数据量; 二、$_FILES 数组 $_FILES超级全局变量作用是存储各种与上传文件有关的信息; $_FILES是一个二维数组，数组中共有5项： $_FILES[“userfile”][“name”] 上传文件的名称 $_FILES[“userfile”][“type”] 上传文件的类型 $_FILES[“userfile”][“size”] 上传文件的大小, 以字节为单位 $_FILES[“userfile”][“tmp_name”] 文件上传后在服务器端储存的临时文件名 $_FILES[“userfile”][“error”] 文件上传相关的错误代码 注:userfile只是一个占位符，代表文件上传表单元素的名字; 因此这个值将根据你所给定的名称有所不同; 三、上传错误信息 $_FILES[‘userfile’][‘error’] 提供了在文件上传过程中出现的错误： UPLOAD_ERR_OK (value = 0) 如果文件上传成功返回0; UPLOAD_ERR_INI_SIZE (value = 1)如果试图上传的文件大小超出了 upload_max_filesize指令指定的值，则返回1; UPLOAD_ERR_FORM_SIZE (value = 2)如果试图上传的文件大小超出了MAX_FILE_SIZE指令（可能嵌入在HTML表单中）指定的值，则返回2; UPLOAD_ERR_PARTIAL (value = 3)如果文件没有完全上传，则返回3; 如网络出现错误，导致上传过程中断; UPLOAD_ERR_NO_FILE (value = 4)如果用户没有指定上传的文件就提交表单，则返回 四、文件上传函数1. is_uploaded_file() is_uploaded_file()函数确定参数filename指定的文件是否使用HTTP POST上传; `例： $file = $_FILES[&quot;file&quot;]; print_r($file); if(is_uploaded_file($file[&apos;tmp_name&apos;])){ copy($file[&apos;tmp_name&apos;],&quot;test2.txt&quot;); }else{ echo &quot;文件上传失败！&quot;; }` 2. move_uploaded_file() move_uploaded_file()作用是将上传文件从临时目录移动到目标目录; 虽然 copy()也可以实现同样功能，但move_uploaded_file()还提供了一种额外的 功能，它将检查由filename输入参数指定的文件确实是通过http post 上传机制 上传的。如果所指定的文件并非上传文件，则移动失败，返回false; `例： move_uploaded_file($_FILES[&apos;userfile&apos;][&apos;tmp_name&apos;],&quot;1/test.jpg&quot;);` 数组一.数组的概念：数组可以理解为有序的（键-值)对组成的数据值的集合; 如果我们把变量理解为单个值的容器，那么数组就是可以包含多个值的容器;根据索引值的不同数组分为：索引数组和关联数组; array(key =&gt; value,key =&gt; value) 二.创建数组与其它语言的数组实现方式不同，php不需要在创建数组时指定其大小;因为php是一种松散类型的语言，所以甚至不需要在使用前先声明; 索引可以是整型数字或者是字符串; 索引数组：索引为整数,如果没有指定索引值则默认为零，依次递增; 关联数组：索引为字符串的数组; 直接对数组变量赋值$arr[key] = value; //高版本[value] 使用函数创建数组:range() 建立一个包含指定范围单元的数组 三、删除 数组或数组元素 unset 释放给定的变量 注意：删除数组元素不会重建索引; 1234$arr = array(1,2,3,4,5);unset($arr[1]);// $arr1 = array_values($arr);//重新要排序下标print_r($arr); 四、常用的数组函数 print_r() 打印数组 count() 取得数组大小 in_array() 检查数组中是否包含某个值123456$arr = array(1,2,3,4,5);if (in_array(11, $arr)) &#123; echo &quot;有&quot;;&#125;else&#123; echo &quot;没有&quot;;&#125; 五、遍历数组arr = [A,B,C,D,E,F] 1. for 循环遍历数组 2. foreach 循环遍历数组 3. 使用数组指针遍历数组 * key() 返回数组当前指针元素的索引; * current() 返回数组当前指针元素的值; * next() 将数组指针向前移动一位，并返回当前指针元素的值; 如果超出了数组元素的末尾，则返回FALSE * prev() 将数组指针往回移动一位, 并返回当前指针元素的值; 如果指针本来就位于数组的第一个位置则返回FALSE; * reset() 将指针指向第一个元素，并返回第一个元素的值 * end() 将数组指针指向最后一个元素, 并返回最后一个元素的值; * each() 返回数组当前指针元素的键和值,并将指针推进一个位置;如果内部指针越过了数组的末端，则 each() 返回 FALSE。 &gt;next()和each()的区别next返回值,each返回键和值(数组) 六、数组排序1. sort() 、 rsort() 对数组的value值进行升序和降序 2. ksort()、krsort() 对数组按索引进行升序或降序, 并保持索引关系 七、字符串与数组转换1. explode() 返回由字符串组成的数组 2. implode() 将数组元素连接成字符串 123456$str = &quot;a,b,c,d,e&quot;;$arr = explode(&quot;,&quot;, $str);//不加要劈开的标点,会报错print_r($arr);echo &quot;&lt;br&gt;&quot;;$str2 = implode(&quot;&quot;, $arr);//类似js的joinecho $str2; 字符串一、输出字符串 echo 是一个语法 ，不是函数echo 没有返回值; echo 可以输出多个值，使用逗号分隔; print 实际上不是一个函数（它是一个语言结构） printf() parseInt(10.55,”8”);//将10.55转化为8进制 %b二进制输出 //brianry %d整数输出 //data %f浮点数输出 //float %s字符串输出 //string printf(“整数：%d”, $str); printf(“浮点数：%.2f”, $str); printf(“字符串：%s”, $str); 1234printf(&quot;二进制:%b&quot;,100);//11001100printf(&quot;二进制:%b&quot;,1);//1printf(&quot;整数:%d&quot;,10.451);//10printf(&quot;浮点数:%.2f&quot;,10.451);//10.45 sprintf() 功能与printf相同，但不会直接输出结果; 12$num = sprintf(&quot;%d&quot;,6.21);//不用echo输出,是不会输出的echo $num; 二、查找与替换 strpos() stripos()与strpos()功能相同，只是查找时不区别大小写 第一次出现的位置;如果没有找到则返回FALSE;//类似indexof str_replace() str_ireplace()与str_replace()功能相同，只是不区分大小写;str_replace(find,change,str) 123456789101112$str = &quot;abcdefgdedc&quot;;$index = 0;$count = 0;$num = strpos($str,&quot;d&quot;,$index);//4是从第几个开始找 str.indexOf(&quot;d&quot;,0);//类似找父级定位,找d的个数while ($num) &#123; $count++; $index = $num+1; // echo $index.&quot;&lt;br&gt;&quot;;//4 8 10 $num = strpos($str, &quot;d&quot;,$index);//下一次&#125;echo $count;//3 三、截取字符串 substr() 从start位置取出length长度的字符，字符串位置开始值为零; 如果没有指定length，那么默认一直到字符串末尾; $str = &quot;abcdefdabkjldf&quot;; echo substr($str,3,1);//从第三个开始截取,第三个参数截取的长度 删除字符串 ltrim 函数删除字符串左侧空格或其他预定义字符; rtrim 函数删除字符串右侧空格或其他预定义字符; trim 函数删除字符串两侧空格或其他预定义字符; 四、其它字符串处理函数 strlen() 获取字符串长度 strtolower() 将字符串转换为小写字母 strtoupper() 将字符串转换为大写字母 strrev() 反转字符串 nl2br() 将字符串中换行 (\\n) 转换成 HTML 换行标签 () strip_tags() 删除字符串中HTML XML PHP 标签 htmlspecialchars() 函数把一些预定义的字符转换为 HTML 实体 正则preg_match,preg_replace,preg_split,preg_greppreg_match/preg_match_all1234$str = &quot;内容1内容2内容3内容4&quot;;//preg_match(&quot;/内容/&quot;,$str);//如果找到就返回1preg_match_all(&quot;/内容/&quot;, $str, $arr);//将要划分的内容,放到$arr里面print_r($arr); 实例二 12345//获取一个页面的部分东西 $con = file_get_contents(&quot;http://www.cnblogs.com/&quot;); $reg = &apos;/&lt;h3\\&gt;.+&lt;\\/h3&gt;/&apos;;//.表示所有 preg_match_all($reg, $con,$arr); print_r($arr); preg_replace1234$str = &quot;abc@163.com,abc@163.com&quot;;$reg = &apos;/@\\d+/&apos;;//js可以不加&quot;&quot;,但是php必须加&quot;&quot;$str = preg_replace($reg, &quot;4ddd&quot;, $str);echo $str; preg_split12345$str = &quot;abc1423de456&quot;;// $reg = &quot;/\\d+/&quot;;//以数字来劈开$reg = &quot;/[a-z]+/&quot;;//以字母来劈开 &quot;,1423,456&quot;;$arr = preg_split($reg, $str);print_r($arr); preg_grep12345678//判断是否有数字,由的话就保存起来$arr = [12,&apos;abc&apos;,53,&apos;c&apos;,10];$reg = &apos;/\\d/&apos;;$newarr = preg_grep($reg,$arr);//返回的下标不会变print_r($newarr); SQL注意的步骤 md5加密是32个字节 A_I是自增 排序规格:utf8_general_ci 字段数:表示有几列 在控制台写代码 ==&gt;执行是ctrl + enter 再控制台写代码要注意insert into user (username) values (‘ass’) ===&gt;字段名一定要加`` 一、SQL 语言简介 SQL (structured Query Language) 结构化查询语言;主要用途是构造各种数据库系统操作指令，如 SELECT、INSERT、UPDATE、DELETE; SQL命令可以分类以下三大类别： DML(Data Manipulation Language 数据处理语言）： 这类命令主要包括 SELECT、INSERT、UPDATE、DELETE等用来从数据表读出数据，把数据存入数据表或是对数据表里的现有记录进行修改的命令; DDL(Data Definition Language 数据定义语言）： 这类命令主要包括CREATE TABLE、ALTER TABLE 等用来定义和改变数据库结构的命令; DCL(Data Control Language 数据控制语言）： 这类命令主要包括GRANT、REVOKE以及另外几个用来帮助人们设置和调整MySQL访问控制机制的SQL命令; 二、查询(SELECT) 简单查询 SELECT * FROM tablename 限制查询结果中的数据列个数 SELECT column1,column2 FROM tablename 确定数据表里有多少条数据记录 SELECT COUNT(id) FROM tablename //计算的同时改变字段名as:SELECT COUNT(id) as len FROM tablename//把字段名改为len 三、WHERE子句 WHERE子句设置查询条件，过滤掉不需要的数据行。 例如查询年龄大于20的记录： SELECT * FROM usertable WHERE age&gt;20 WHERE子句可包括各种条件运算符： 比较运算符 ` = 等于 大于 = 大于等于 &lt; 小于 &lt;= 小于等于 &lt;&gt; 不等于` 逻辑运算符 AND 如果组合的条件都是TRUE,返回TRUE OR 如果组合的条件其一是TRUE,返回TRUE NOT 如果条件是FALSE,返回TRUE 四、限制查询结果中的数据记录个数(LIMIT)LIMIT子句用于强制SELECT语句返回指定的记录数。LIMIT接受一个或两个数字参数。参数必须是一个整数常量。如果给定两个参数，第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的最大数目。 注意：初始记录行的偏移量是0而不是1。 (适合用于分页) `例： 检索前5个记录行 SELECT * FROM table LIMIT 5; 检索记录行 6-15 SELECT * FROM table LIMIT 5,10; ` 五、对查询结果进行排序 (ORDER BY) 使用ORDER BY子句对查询返回的结果排序。 ORDER BY子句的语法格式为： ORDER BY {column_name [ASC|DESC]} [,…n] 其中ASC表示升序，为默认值，DESC为降序 例： SELECT * FROM user ORDER BY uid ASC SELECT * FROM user ORDER BY uid DESC SELECT * FROM user ORDER BY regdate DESC,username ASC; 六、插入数据记录(INSERT)`例： INSERT INTO user (username,password) VALUES (&apos;admin&apos;,&apos;123456&apos;)` 一次插入多条记录INSERT INTO user (username, password) VALUES (&#39;user1&#39;, &#39;123456&#39;), (&#39;user2&#39;,&#39;123456&#39;) 七、修改数据记录（UPDATE）`例： UPDATE user SET username = &apos;admin1&apos;, passwd =&apos;12345678&apos; WHERE uid = 10` 八、删除数据记录（DELETE）`例： DELETE FROM user WHERE uid = 10`","tags":[]},{"title":"函数库","date":"2016-11-08T09:30:22.000Z","path":"2016/11/08/函数库/","text":"函数概念函数可以使程序更具模块化,拥有良好的结构; 函数分为内置函数和自定义函数 函数名不区分大小写,不过在调用函数的时候，通常使用其在定义时相同的形式; php不支持函数重载, 所以自定义函数不能和内置函数重名; 传递参数 值传递(传值): 函数内对参数值的改变不会影响函数外部的值; 引用传递(传址): 有些情况下，可能希望在函数体内对参数的修改在函数体外也能反映; 使用引用传递参数要在参数前加上&amp;符号; 变量本身传入，传入后的变量与原变量建立联系; 函数体内变量的变化，会影响到原变量本身; 默认参数值: 可以为参数指定默认值，在没有提供其他值的情况下，则将默认值自动赋 变量分为:全局变量，局部变量，静态变量全局变量 函数体内定义的变量为局部变量，只在函数体内可见; 局部变量的作用域：从声明它的那条语句开始到函数结束; 局部变量 函数体外定义的变量为全局变量，与局部变量相反，全局变量可以在程序的任何地方访问; 如果在函数体中需要使用全局变量，使用 global 关键字访问; 全局变量的作用域：从声明它的那条语句开始到文件末尾; 静态变量 局部变量在函数退出时会被撤消，与局部变量不同，静态变量在函数退出时不会丢失值，并且再次调用函数时还能保留这个值; 在变量名前面加上 static 关键字就可以声明一个静态变量;(内存溢出:指没用的东西再占用内存) 函数库 通常将常用的函数组织到函数库中，可以在以后类似的应用程序中重复使用。 include() request() include_once() require_once() 需要调用时使用include()或require()将函数库包含到脚本中; include_once()/require_once()的作用与include()/require()相同，不过它会首先验证是否已经包含了该文件，如果已经包含，则不再执行(只引用一次) 如果require()包含文件出错时，脚本将停止执行。 而使用include()脚本将继续执行。 打开和关闭文件 fopen() 函数将resource绑定到一个流或句柄。绑定之后，脚本就可以通过句柄与此资源交互; 例1:以只读方式打开一个位于本地服务器的文本文件$fh = fopen(&quot;test.txt&quot;, &quot;r&quot;); 例2：以只读方式打开一个远程文件$fh = fopen(&quot;http://www.baidu.com&quot;, &quot;r&quot;); fclose(handle) 将 handle 指向的文件关闭 。如果成功则返回 TRUE，失败则返回 FALSE;虽然每个请求最后都会自动关闭文件，但明确的关闭打开的所有文件是一个好的习惯; 读取文件 php 提供了很多从文件中读取数据的方法，不仅可以一次只读取一个字符，还可以一次读取整个文件。 fread(handle,length)函数从handle指定的资源中读取length个字符,当到达EOF或读取到length个字符时读取将停止。如果要读取整个文件，使用filesize(handle)函数确定应该读取的字符数; fgets(handle)函数从handle指定的资源中读取一行字符。 feof() 函数检测是否已到达文件末尾 (eof)。 file(url)函数将文件读取到数组中，各元素由换行符分隔。 file_get_contents(url)函数将文件内容读到字符串中; 写入文件 fwrite(handle)==&gt;函数将string的内容写入到由handle指定的资源中。如果指定length参数，将在写入Length个字符时停止。 file_put_contents(url,str)==&gt;函数将一个字符串写入文件，与依次调用fopen(),fwrite(),fclose()功能一样; 解析目录路径的函数 basename(path,suffix)==&gt;返回路径中的文件名部份，当指定了可选参数suffix会将这部分内容去掉; dirname(path)==&gt;返回路径中的目录部份; pathinfo()==&gt;返回一个关联数组，其中包括路径中的三个部份：目录名，文件名，扩展名 获取当前文件路径==&gt; $_SERVER[“SCRIPT_FILENAME”] 其它文件操作函数 filesize(handle)==&gt; 取得文件的大小，以字节为单位 filectime(url)==&gt; 取得文件的创建时间，以unix时间戳方式返回 fileatime(url)==&gt; 返回文件的最后改变时间; filemtime(url)==&gt; 返回文件的最后修改时间; 注：”最后改变时间”不同于 “最后修改时间”。最后改变时间指的是对文件inode数 据的任何改变，包括改变权限，所属组，拥有者等; 而最后修改时间指的是对文 件内容的修改 file_exists(url)==&gt; 检查文件或目录是否存在，如果存在返回true, 否则返回false; is_readable(url)==&gt; 判断文件是否可读，如果文件存在并且可读，则返回true; is_writable(url)==&gt; 判断文件是否可写，如果文件存在并且可写，则返回true; date_default_timezone_set(“Asia/Shanghai”);时区设置date(“Y-m-d H:i:s”,time)时间格式 读取目录 opendir()打开目录句柄; closedir()关闭目录句柄 readdir()返回由dir_handle指定目录中的各个元素。可以使用此函数列出给定目录中的所有文件和子目录 scandir(directory)返回一个包含有 directory 指定路径中的文件和目录的数组;失败返回false; rmdir(pathname)删除目录 注意：目录必须为空，否则报错； mkdir(pathname)尝试新建一个由 pathname 指定的目录。 复制，移动，删除文件 copy(source,dest)将文件从 source 拷贝到 dest。如果成功则返回 TRUE，失败则返回 FALSE rename(oldname,newname)尝试把 oldname 重命名为 newname。 如果成功则返回 TRUE，失败则返回FALSE。 重命名是改变路径相当于移动 unlink()删除文件，如果删除成功返回true, 否则返回false; GET与POST GET==&gt; 所有表单输入的数据被加载到请求的URL地址后面; GET方式提交数据只能传递文本，能够提交的数据量大小有限，安全性差; POST==&gt; POST提交数据的方式把表单的数据打包放入http请求中; POST能够提交更多的数据; 处理多值表单控件多值表单控件（如复选框和多选框），大大提高了基于web的数据收集能力; 因为这些组件是多值的，所以表单处理函数必须能够识别一个表单变量中可能有 多个值;为了让php识别一个表单变量的多个值（即考虑为数组），需要对表单名 (元素的name属性值）增加一对中括号，如: 接收数据 表单提交的数据会自动封装为数组; 用$_GET, $_POST, 或$_REQUEST获得表单提交的数据; $_REQUEST可以获取以POST方法和GET方法提交的数据，但是速度比较慢 //静态界面 &lt;a href=&quot;10.GET_POST.php?type=add&amp;dir=kkk&quot;&gt;创建文件&lt;/a&gt; &lt;a href=&quot;10.GET_POST.php?type=remove&amp;dir=kkk&quot;&gt;删除文件&lt;/a&gt; &lt;!-- action=&quot;http://www.baidu.com/s&quot; --&gt; &lt;form action=&quot;10.GET_POST.php&quot; method=&quot;get&quot;&gt; name:&lt;input type=&quot;text&quot; name=&quot;name&quot;&gt; pwd:&lt;input type=&quot;password&quot; name=&quot;pwd&quot;&gt; &lt;input type=&quot;checkbox&quot; name=&quot;check[0]&quot;&gt; &lt;input type=&quot;checkbox&quot; name=&quot;check[1]&quot;&gt; &lt;input type=&quot;checkbox&quot; name=&quot;check[2]&quot;&gt; &lt;input type=&quot;checkbox&quot; name=&quot;check[3]&quot;&gt; &lt;input type=&quot;submit&quot; /&gt; &lt;/form&gt; //后台代码 $type = $_GET[&quot;type&quot;]; $dir = $_GET[&quot;dir&quot;]; if ($type==&quot;add&quot;) { mkdir($dir); echo &quot;创建成功&quot;; }else if ($type ==&quot;remove&quot;) { rmdir($dir); echo &quot;删除成功&quot;; } echo &apos;&lt;script type=&quot;text/javascript&quot;&gt; setTimeout(function(){ location.href = &quot;baidu.html&quot;; },3000); &lt;/script&gt;&apos;;","tags":[]},{"title":"php中基本属性的总结","date":"2016-11-07T11:15:29.000Z","path":"2016/11/07/php1/","text":"phpphp php可以写再标签里面 script里面 标签里面的id,class中 变量 变量以美元符 $ 开头，然后是变量名; 变量名由字母或下划线开头，由字母，下划线，数字组成; 变量名区分大小写; php 是弱类型的语言，不需要事先声明变量的数据类型; php可以不用显示的声明变量就直接使用，不过好的编码习惯：所有的变量在使用前应该进行声明; 值赋值 值赋值：就是将赋值表达式的值复制到变量1234$var = &quot;abc&quot;;echo &quot;$var&lt;br&gt;&quot;;//变量的调用是可以有双引号或者不用,不能用单引号echo &quot;&#123;$var&#125;这里面是内容&quot;;//如果变量后面有中文,变量要加大括号echo &quot;&lt;br&gt;&quot;; 引用赋值 引用赋值：php4引入了引用赋值功能，创建的变量与另一个变量引用的内容相同 其中的一个变量改变,赋值的那个变量也随之改变1234$var1 = &quot;hello&quot;;//内存地址X001 = hello$var2 = &amp;$var1;//内存地址X001 = hello &amp;是内存地址,用了之后$var1和$var2的地址就是一样$var2 = &quot;123&quot;;//内存地址X001 = 123echo &quot;$var1 &lt;br&gt;&quot;;//123 变量的变量123$he = &quot;hello&quot;;$$he = &quot;world&quot;;echo $he.$hello.&quot;&lt;br&gt;&quot;;//helloworld PHP的超全局变量 $_SERVER 服务器变量 该全局变量包含着服务器和客户端配置及当前请求环境的有关信息 $_SERVER[‘SERVER_NAME’]; : 当前运行脚本所在的服务器的主机名 $_SERVER[‘REMOTE_ADDR’] : 客户端IP地址 $_SERVER[‘REQUEST_URI’] : URL的路径部份 $_SERVER[‘HTTP_USER_AGENT’] : 操作系统和浏览器的有关信息 12345//实例echo &quot;主机名: &quot;.$_SERVER[&quot;SERVER_NAME&quot;].&quot;&lt;br&gt;&quot;;echo &quot;PI地址:&quot;.$_SERVER[&quot;REMOTE_ADDR&quot;].&quot;&lt;br&gt;&quot;;echo &quot;URL的路径部份:&quot;.$_SERVER[&quot;REQUEST_URI&quot;].&quot;&lt;br&gt;&quot;;echo &quot;操作系统和浏览器的有关信息:&quot;.$_SERVER[&quot;HTTP_USER_AGENT&quot;].&quot;&lt;br&gt;&quot;; 常量 常量是指在程序执行中无法修改的值。如 PI (3.1415926); 常量的变量名不用加$ 在脚本执行期间该值不能改变; 常量对大小写敏感，通常常量名总是大写; 常量是全局的，可以在脚本的任何地方引用; 常量分为内置常量和自定义常量; 常量使用define()函数定义; 常量的定义 常量是不可以被修改的123define(&quot;AA&quot;, 12);//AA = 1;//常量不可以修改echo AA;//这里的常量就不用加双引号 内置常量 PHP_OS // PHP所在的操作系统的名字 PHP_VERSION //当前 PHP 的版本 12echo &quot;PHP所在的操作系统的名字:&quot;.PHP_OS.&quot;&lt;br&gt;&quot;;echo &quot;当前 PHP 的版本:&quot;.PHP_VERSION.&quot;&lt;br&gt;&quot;; 魔术常量 LINE 文件中的当前行号; FILE 文件的完整路径和文件名; FUNCTION 函数名称;(这里就不区分大小写) CLASS 类的名称; METHOD 类的方法名;12345678echo __LINE__;echo &quot;&lt;br&gt;&quot;;echo __FILE__;echo &quot;&lt;br&gt;&quot;;showFn();function showFn()&#123;//函数名不能多次创建一致 echo __FUNCTION__;&#125; php的数据类型标量数据类型 字符串 (string) 字符串有三种定义方式：单引号，双引号，定界符(heredoc); 单引号字符串中出现的变量不会被变量的值替代; 双引号字符串中最重要的一点是其中的变量会被变量值替代;如果遇到美元符号($),解析器会尽可能多地取得后面的字符以组成一个合法的变量名,如果想明确的指定名字的结束，用花括号把变量名括起来。 字符串定界的方法使用定界符语法 “&lt;&lt;&lt;END” 在PHP定界符中的任何特殊字符 都不需要转义 PHP定界符中的PHP变量会被正常的用其值来替换 使用定界符要注意：结束标识符所在的行不能包含任何其它字符，这意味着该标识符不能被缩进，在分号之前之后都不能有任何空格或制表符; 12345 $a = 123; $haha =&lt;&lt;&lt;END 内容内容内容内容内容内容&#123;$a&#125;END;echo $haha; 整型(integer) 浮点型(float, double) 布尔型（bool） 复合数据类型 数组 eg:$week = array(‘星期一’,’星期二’,’星期三’); 对象 eg:$db = new db; 特殊数据类型 资源$fh = fopen(&quot;test.txt&quot;,&quot;r&quot;); null 无，表示没有值，null不表示空格，也不表示0;12345以下情况，则认为是null:没有设置为任何预定义的变量;明确的赋值为null;使用函数unset()清除; 12345$var_1 = null;// unset($var_1);//清除// echo $var_1;//调用会报错echo gettype($var_1);//NULLecho &quot;&lt;br&gt;&quot;; 类型自动转换 因为php对于类型定义非常的松散，所以有时会根据引用变量的环境，将变量自动转换为 最适合的类型; gettype() 返回变量的类型 is_type() 查看变量是否属于某个类型,是返回 TRUE ,否返回 FALSE; var_dump()函数用来得到变量的类型和值的详细信息 123456789101112131415161718192021222324252627282930313233$num = 123;$float = 1.12;$bol = true;$str = &quot;haha&quot;;$arr = array(10);echo gettype($num);//integer 整形echo &quot;&lt;br&gt;&quot;;echo gettype($float);//double 浮点echo &quot;&lt;br&gt;&quot;;echo gettype($bol);//boolean true falseecho &quot;&lt;br&gt;&quot;;echo gettype($str);//string 字符串echo &quot;&lt;br&gt;&quot;;echo gettype($arr);//array 数组echo &quot;&lt;br&gt;&quot;;echo &quot;&lt;br&gt;是否是字符串:&quot;;if (is_string($str)) &#123; echo &quot;yes&quot;;&#125;else&#123; echo &quot;no&quot;;&#125;echo &quot;&lt;br&gt;是否是布尔值:&quot;;if (is_bool($bol)) &#123; echo &quot;yes&quot;;&#125;else&#123; echo &quot;no&quot;;&#125;echo &quot;&lt;br&gt;是否是数组:&quot;;if (is_array($arr)) &#123; echo &quot;yes&quot;;&#125;else&#123; echo &quot;no&quot;;&#125; 运算符算术运算符 算术运算符，用于完成各种算术运算; 加法运算 $a + $b 减法运算 $a - $b 乘法运算 $a * $b / 除法运算 $a / $b % 取模运算（求余数) $a % $b 赋值运算符 赋值运算符，将一个数据值赋给一个变量;组合赋值运算符，在赋值之前会完成某个运算; 字符串运算符用于拼接字符串, 拼接表示将两个或多个对象组合起来; 递增和递减运算符将变量的当前值加1或减1，可以使代码更简洁; 字符串运算符 字符串运算符用于拼接字符串, 拼接表示将两个或多个对象组合起来; eg:$a .= 5 拼接赋值 $a = $a.5 递增(++)和递减(–)运算符 递增和递减运算符将变量的当前值加1或减1，可以使代码更简洁; ++$i 先加 $i的值加1，然后再返回$i的值; $i++ 后加 先返回$i的值，然后再将$i的值加1; –$i 先减 $i的值减1，然后再返回$i的值; $i– 后减 先返回$i的值，然后再将$i的值减1; 逻辑运算符 利用逻辑运算符可以根据多个变量的值进行判断，这使得控制程序的流程成为可能，逻辑操作符常用于控制结构中，如if条件和while及for循环; &amp;&amp; AND 逻辑与 || OR 逻辑或 ! NOT 逻辑非 比较运算符 比较运算符，返回一个布尔值 TRUE 或 FALSE; 大于 &lt; 小于 = 大于或等于 &lt;= 小于或等于 != 不等于 &lt;&gt; 不等于 == 等于 === 全等于 （两个比较的内容里，类型也要一样） !== 全不等 三元运算符 expression1 ? expression2 : expression3$a = 2&gt;1?2:1;echo $a; 条件语句 if语句 switch语句 while语句 do..while语句 for语句 foreach语句==&gt;类似javascript12345678910111213 语法格式1： foreach(array_expr as $value)&#123; //statements &#125; 语法格式2： foreach(array_expr as $key=&gt;$value)&#123; //statements &#125;``` ## 九九乘法表 &lt;?php for ($i=1; $i &lt; 10; $i++) { echo ““; for ($j=1; $j &lt;= $i; $j++) { if ($j&lt;=$i) { $sum = $i$j; echo “$j”.”“.”$i”.”=”.”$sum”.”“; }else{ echo ““; } } echo ““; }?&gt;```","tags":[]},{"title":"canvas的画布","date":"2016-11-02T11:19:36.000Z","path":"2016/11/02/canvas项目/","text":"eCharts 画折线图和饼图等(是js文件) canvas画饼图 注意点:textBaseline的默认值是alphabetic 123456789101112131415161718192021222324252627282930313233343536373839404142434445var canvas = document.querySelector(&apos;canvas&apos;);var ctx = canvas.getContext(&apos;2d&apos;);//数据var arr =[ &#123;&quot;title&quot;:&quot;第一季度&quot;,&quot;num&quot;:&quot;200&quot;,&quot;color&quot;:&quot;red&quot;&#125;, &#123;&quot;title&quot;:&quot;第二季度&quot;,&quot;num&quot;:&quot;100&quot;,&quot;color&quot;:&quot;green&quot;&#125;, &#123;&quot;title&quot;:&quot;第三季度&quot;,&quot;num&quot;:&quot;300&quot;,&quot;color&quot;:&quot;blue&quot;&#125;, &#123;&quot;title&quot;:&quot;第四季度&quot;,&quot;num&quot;:&quot;300&quot;,&quot;color&quot;:&quot;yellow&quot;&#125;, &#123;&quot;title&quot;:&quot;第五季度&quot;,&quot;num&quot;:&quot;300&quot;,&quot;color&quot;:&quot;pink&quot;&#125;];//计算总数var count = 0;for (var i = 0;i &lt; arr.length;i++) &#123; count += Number(arr[i].num);//计算arr里面的num值&#125;//圆的偏转的角度var deg1 = 0;var deg2 = 0;for (var i = 0;i &lt; arr.length;i++) &#123; deg1 = deg2;//deg1总等于deg2的上一个值 deg2 += arr[i].num/count*360;//计算所占比例的角度 draw(deg1,deg2,arr[i].color); drawTitle(300,10+25*i,arr[i].color,arr[i].title);&#125;//画圆function draw(deg1,deg2,color)&#123; ctx.beginPath(); ctx.fillStyle = color; ctx.moveTo(200,200); ctx.arc(200,200,100,Math.PI/180*deg1,Math.PI/180*deg2); ctx.fill(); ctx.closePath();&#125;//小方块加文字function drawTitle(x,y,color,title)&#123; ctx.beginPath(); ctx.fillStyle = color; ctx.fillRect(x,y,20,20); ctx.font=&quot;15px 黑体&quot;; ctx.textBaseline = &quot;middle&quot;;//默认是alphabetic ctx.fillStyle = &quot;black&quot;; ctx.fillText(title,x+30,y+10);//30是小矩形的宽高再加点间距 10是小矩形的宽度/2 ctx.fill();&#125; canvas画放大镜 注意点:图片是有加载的时间,所以\u0010获取图片宽高是会出现一些问题1234567891011121314151617181920212223242526272829303132333435363738394041var wrap = document.querySelector(&apos;.wrap&apos;) var minImg = wrap.children[0]; var div = wrap.children[1]; var canvas = document.querySelector(&apos;canvas&apos;); var ctx = canvas.getContext(&quot;2d&quot;); //创建大图 var maxImg = new Image(); maxImg.src = &quot;img/max.jpg&quot;; wrap.onmouseenter = function()&#123; div.style.display = &quot;block&quot;; &#125; wrap.onmouseleave = function()&#123; div.style.display = &quot;none&quot;; &#125; //这里不是拖拽,是鼠标的移动 document.onmousemove = function(e)&#123; //鼠标经过时,鼠标一直处于小方块的中心 var x = e.clientX-wrap.offsetLeft-1-div.offsetWidth/2; var y = e.clientY-wrap.offsetTop-1-div.offsetWidth/2; //判断碰撞 if (x&lt;0) &#123; x = 0 &#125;else if (x&gt;wrap.clientWidth-div.offsetWidth) &#123; x = wrap.clientWidth-div.offsetWidth; &#125; if (y&lt;0) &#123; y = 0; &#125;else if (y&gt;wrap.clientHeight-div.offsetHeight) &#123; y = wrap.clientHeight-div.offsetHeight; &#125; // var scale = maxImg.offsetWidth/minImg.offsetWidth;//要图片加载完毕,才能计算 var scale = 800/350; ctx.drawImage(maxImg,x*scale,y*scale,100*scale,100*scale,0,0,canvas.width,canvas.height); div.style.left = x+&quot;px&quot;; div.style.top = y+&quot;px&quot;; &#125; canvas的事件isPointInPath isPointInPath判断x,y的位置是否再当前绘制的路径上面 如果出现多个矩形或是圆,只有最后的方块才能执行isPointInPath,解决方案是重新画,再用isPointInPath判断 注意点:isPointInPath的返回值是false和true 123456789101112131415161718var canvas = document.querySelector(&apos;canvas&apos;);var ctx = canvas.getContext(&apos;2d&apos;);ctx.rect(50,50,100,100);//这里不能用fillRect()ctx.fill();ctx.beginPath();ctx.arc(200,200,50,0,Math.PI*2);ctx.fill();ctx.closePath();canvas.onclick = function(e)&#123; var x = e.clientX-canvas.offsetLeft; var y =e.clientY-canvas.offsetTop; //(判断点是否再这个路径里面) isPointInPath判断x,y的位置是否再当前绘制的路径上面 console.log(ctx.isPointInPath(x,y));//可以判断圆,但是不可以判断正方块 //如果要画的东西都能判断,就要重新画一次,再判断 // ctx.arc(200,200,50,0,Math.PI*2);console.log(ctx.isPointInPath(x,y)); // ctx.rect(50,50,100,100);console.log(ctx.isPointInPath(x,y));&#125; 碰撞方块的动画(新的动画方法:requestAnimationFrame) requestAnimationFrame cancelAnimationFrame(是取消)","tags":[]},{"title":"canvas的刮彩票小项目,canvas的关于图片的属性","date":"2016-11-01T12:49:57.000Z","path":"2016/11/01/Day39_canvas2/","text":"图形的组合方式 source-over：为属性globalCompositeOperation属性的默认值表示新图形覆盖在原图形之上 source-atop：只绘制新图形与原图形相重叠的部分，以及原图形其他部分 source-in：只绘制新图形与原图形重叠的部分，新图形与原图形其他部分变透明 source-out：只绘制新图形与原图形不重叠的部分；新图形与原图形其他部分变透明 destination-over：表示原图形覆盖在新图形之上destination-atop：只绘制原图形与新图形相重叠的部分，以及新图形其他部分\u0013 destination-in：只绘制原图形与新图形重叠的部分，原图形与新图形其他部分变透明 destination-out：只绘制原图形与新图形不重叠的部分；原图形与新图形其他部分变透明 lighter：原有图形与新图形都绘制，重叠部分加色处理 xor：只绘制原、新图形不重叠之处，其他做透明色 copy：只绘制新图形，覆盖掉原图 实例:刮彩票 注意点style.left获取的是字符串(带px),offsetLeft获取的是数值 12345678910111213141516171819202122232425262728293031323334&lt;div class=&quot;wrap&quot;&gt; 谢谢惠顾! &lt;canvas&gt;&lt;/canvas&gt;&lt;/div&gt;var wrap = document.querySelector(&quot;.wrap&quot;); var canvas = wrap.children[0]; //设置canvas的实际宽度和高度 canvas.width = wrap.clientWidth; canvas.height = wrap.clientHeight; var ctx = canvas.getContext(&quot;2d&quot;); //填充画布颜色 ctx.fillStyle = &quot;#ccc&quot;; ctx.fillRect(0,0,canvas.width,canvas.height); canvas.onmousedown = function(e)&#123; var disX = wrap.offsetLeft-1;//-1是减去边框 var disY = wrap.offsetTop-1; ctx.globalCompositeOperation = &quot;destination-out&quot;; ctx.beginPath(); document.onmousemove = function(e)&#123; var x = e.clientX - disX; var y = e.clientY - disY; // ctx.arc(x,y,5,0,Math.PI*2); ctx.lineWidth = 10; ctx.lineCap = &quot;round&quot;; ctx.lineTo(x,y); ctx.stroke(); &#125; return false; &#125; document.onmouseup = function()&#123; document.onmousemove = &quot;&quot;; &#125; createPattern是图片的平铺 createPattern(img,type) img：图片 type：1) repeat整个画布平铺 2) repeat-x在x轴方向上平铺 3) repeat-y在y轴方向上平铺 4) no-repeat不平铺 注意点:img是有onload事件##.clip()\u0010剪切 12345678910var canvas = document.querySelector(&quot;canvas&quot;);var ctx = canvas.getContext(&quot;2d&quot;);var img = document.querySelector(&quot;img&quot;);ctx.rect(100,100,400,400);//画一个空心矩形ctx.clip();//剪切img.onload = function()&#123; var c = ctx.createPattern(img,&quot;repeat&quot;); ctx.fillStyle = c; ctx.fillRect(0,0,800,800);&#125; drawImage 绘制图像：把图片绘制在画布上面drawImage(img,x,y) 1)img：图片2)x：图片横坐标的起始值3)y：图片纵坐标的起始值 绘制固定宽高的图像：drawImage(img,x,y,w,h) 1)img：图片;2)x：图片横坐标的起始值;3)y：图片纵坐标的起始值;4)w：在画布中图片显示的宽度;5)h：在画布中图片显示的高度; 复制或放大图像局部：drawImage(img,x,y,w,h,rx,ry,rw,rh) 1)img：图片2)x、y：源图片的坐标3)w、h：在源图片上裁剪的宽、高4)rx、ry：显示在画布中的坐标5)rw、rh：显示在画布中的宽、高 getImageData,putImageData和DataURL必须要再服务器上跑 getImageData 是对应rgba getImageData的参数有4个,putImageData的参数有3(像drawImage) .data是获取像素点数据 注意点:颜色的取反 255-num 和 num 是相反颜色 例如:rgb(0,0,0)–(黑色) 那么rgb(255,255,255)–(白色) 把canvas里面的图片数据转成base64的地址数据格式 base64是可以加密也可以解密 123456789101112131415161718192021222324252627282930var btn = document.querySelector(&apos;button&apos;);var canvas = document.getElementsByTagName(&apos;canvas&apos;)[0];var img = document.getElementsByTagName(&apos;img&apos;)[0];var ctx = canvas.getContext(&apos;2d&apos;);img.onload = function()&#123; //获取画板像素点数据 ctx.drawImage(img,0,0); var imageData = ctx.getImageData(0,0,100,203); // console.log(data); //颜色取反 255-本来颜色=取反的颜色 //换为黑白色 for (var i = 0;i&lt;imageData.data.length; i+=4) &#123; var c = imageData.data[i]*.3+imageData.data[i+1]*.59+imageData.data[i+2]*.11;//是黑白 imageData.data[i] = c; imageData.data[i+1] = c; imageData.data[i+2] = c; &#125; &lt;!--是获取颜色的反色 for (var i = 0;i&lt;imageData.data.length; i+=4) &#123;//为什么加4 rgba a:255 imageData.data[i] = 255-imageData.data[i];//r imageData.data[i+1] = 255-imageData.data[i+1];//g imageData.data[i+2] = 255-imageData.data[i+2];//b &#125;--&gt; ctx.putImageData(imageData,0,0); //把canvas里面的图片数据转成base64的地址数据格式 base64是可以加密也可以解密 var url = canvas.toDataURL(&quot;image/png&quot;); console.log(url);&#125; 时钟实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; canvas&#123; border:1px solid black; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas width=&quot;400&quot; height=&quot;400&quot;&gt;&lt;/canvas&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt;var canvas = document.querySelector(&quot;canvas&quot;);var ctx = canvas.getContext(&quot;2d&quot;);ctx.translate(200,200);//画背景bg();function bg()&#123; var deg = 0; var r = 150; ctx.beginPath(); for (var i = 0;i &lt; 13;i++) &#123; // setInterval(function()&#123; //看动画效果 deg += 30; var x = Math.sin(Math.PI/180*deg)*r; var y = -Math.cos(Math.PI/180*deg)*r; ctx.lineTo(x,y); // ctx.arc(x,y,5,0,Math.PI*2); // ctx.stroke(); // &#125;,30); &#125; ctx.closePath(); //填充颜色 var c = ctx.createRadialGradient(0,0,0,0,0,150); c.addColorStop(0,&quot;#22f&quot;); c.addColorStop(1,&quot;#0ef&quot;); ctx.fillStyle = c; ctx.fill();&#125;//画刻度kedu();function kedu()&#123; var deg = 0; for (var i = 0;i &lt; 60;i++) &#123; ctx.save(); ctx.rotate(Math.PI/30*i); ctx.beginPath(); ctx.moveTo(0,-150); if (i%5==0) &#123; ctx.lineWidth = 5; ctx.lineTo(0,-135); &#125;else&#123; ctx.lineWidth = 3; ctx.lineTo(0,-138); &#125; ctx.strokeStyle = &quot;white&quot;; ctx.stroke(); ctx.restore(); &#125;&#125;//画数字num();function num()&#123; for (var i = 1;i &lt; 13;i++) &#123; // ctx.save(); // ctx.rotate(Math.PI/6*i); var x = Math.sin(Math.PI/6*i)*120; var y = -Math.cos(Math.PI/6*i)*120; ctx.font = &quot;20px 黑体&quot;; ctx.textBaseline = &quot;middle&quot;; ctx.textAlign = &quot;center&quot;; ctx.fillStyle = &quot;white&quot;; ctx.fillText(i,x,y+3); // ctx.restore(); &#125;&#125;function sFn(deg)&#123; ctx.save(); ctx.rotate(Math.PI/180*deg); ctx.beginPath(); ctx.moveTo(0,5); ctx.lineTo(0,-120); ctx.strokeStyle = &quot;white&quot;; ctx.stroke(); ctx.closePath(); ctx.restore();&#125;//分针// mFn(30);function mFn(deg)&#123; ctx.save(); ctx.rotate(Math.PI/180*deg); ctx.beginPath(); ctx.moveTo(0,5); ctx.lineTo(0,-100); ctx.strokeStyle = &quot;white&quot;; ctx.lineCap = &quot;round&quot;;//让线的两边变为圆 ctx.lineWidth = 3; ctx.stroke(); ctx.closePath(); ctx.restore();&#125;// hFn(60);function hFn(deg)&#123; ctx.save(); ctx.rotate(Math.PI/180*deg); ctx.beginPath(); ctx.moveTo(0,5);//-2.5是想让旋转更为中心点 ctx.lineTo(0,-80); ctx.strokeStyle = &quot;white&quot;; ctx.lineWidth = 5; ctx.stroke(); ctx.closePath(); ctx.restore();&#125;//针setInterval(function()&#123; var date = new Date(); var s = date.getSeconds(); var m = date.getMinutes(); var h = date.getHours(); ctx.clearRect(-200,-200,400,400); bg(); kedu(); num(); sFn(s*6); mFn(m*6); hFn(h*30+m*6/360*30);&#125;,1000);&lt;/script&gt;&lt;/html&gt;","tags":[]},{"title":"面向对象的模式,继承,构造函数,深拷贝和浅拷贝的知识点","date":"2016-10-29T01:05:53.000Z","path":"2016/10/29/Day37面向对象1/","text":"面向对象js 对象：属性和方法的集合 属性：其实就是变量（只不过有个归属） 方法：其实就是函数（只不过有个归属） 类：一组同样属性和方法的对象的集合(构造函数) 模式 工厂模式 工厂模式是软件工程领域一种广为人知的设计模式，而由于在ECMAScript中无法创建类，因此用函数封装以特定接口创建对象。其实现方法非常简单，也就是在函数内创建一个对象，给对象赋予属性及方法再将对象返回即可。 构造函数模式 函数名首写字母为大写（虽然标准没有严格规定首写字母为大写，但按照惯例，构造函数的首写字母用大写 1. 没有显示的创建对象 直接将属性和方法赋值给了this对象 没有return语句 使用new创建对象 能够识别对象（这正是构造函数模式胜于工厂模式的地方 构造函数虽然好用，但也并非没有缺点，使用构造函数的最大的问题在于每次创建实例的时候都要重新创建一次方法（理论上每次创建对象的时候对象的属性均不同，而对象的方法是相同的），然而创建两次完全相同的方法是没有必要的，也浪费内存。 原型 我们创建的每个函数都有prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。使用原型对象的好处就是可以让所有对象实例共享它所包含的属性及方法。 原型链 123456789//工厂模式function obj(name)&#123; var obj = &#123;&#125;;//创建对象 var obj = new Object(); obj.name = name; obj.show = function()&#123; console.log(this.name);//obj.name &#125; return obj; &#125; 123456789101112131415161718192021222324//构造函数 function Person(name,age)&#123; this.name = name; this.age = age; &#125; //Person的原型,构造对象的时候不需要再创建以下方法,需要的时候直接调用 Person.prototype = &#123;//缺点是东西是写死了的 showName:function()&#123; console.log(this.name); &#125;, showAge:function()&#123; console.log(this.age); &#125;, index:5 &#125; var a = new Person(&quot;aa&quot;,12); var b = new Person(&quot;bb&quot;,13); //不会改变原型里面的属性,改变的是a自己的属性 a.index = 10;//只改自己的index属性 //改变原型里面的属性方法只能通过原型的属性 Person.prototype.index = 20;//a和b都能调用的index,而且输出的都是20 a.showName();//aa b.showName();//bb 1234567//原型链最顶是object for (var i = 0;i&lt;5;i++) &#123; Food.prototype[&quot;Food&quot;+i] = i; Food.prototype = new Food;//对象&#125;function Food()&#123;&#125;console.log(new Food); 继承 call apply方法继承 (apply只有两个参数) 原型继承 123456789101112131415161718192021222324//继承 function Parent(name)&#123; this.name = name; this.fang = &quot;3套&quot;; this.car = &quot;11台&quot;; &#125; Parent.prototype = &#123; show:function()&#123; console.log(&quot;房&quot;+this.fang+&quot;,车&quot;+this.car); &#125; &#125; //将Parent的原型继承给Son (原型继承) // Son.prototype = Parent.prototype; Son.prototype = new Parent(); function Son(name)&#123; //Son继承Parent函数里面的属性,但是不继承Parent里面的prototype的方法和属性 // Parent.call(this); //arguments可以代替所有的参数 ==&gt;name参数 Parent.apply(this,arguments); &#125; var a = new Son(&quot;haha&quot;); console.log(a.fang); console.log(a.name); a.show(); 浅拷贝和深拷贝 for in除了可以循环不知道的函数中参数的个数,还可以循环对象中的属性 1234567891011121314151617181920212223242526//浅拷贝:只是表面的拷贝,但是第一层的属性值改变是不会印象最先的属性值 var div = &#123; id:&quot;wrap&quot;, style:&#123; width:&quot;100px&quot;, height:&quot;100px&quot;, background:&quot;red&quot; &#125;, click:function()&#123; console.log(&quot;click&quot;); &#125;, children:[&#123;a1:&#123;&#125;&#125;,&#123;a2:&#123;&#125;&#125;,&#123;a3:&#123;&#125;&#125;,&#123;a4:&#123;&#125;&#125;] &#125; //封装函数,就不用一个一个复制 function copy(p)&#123; var c = &#123;&#125;; for (var key in p) &#123;//for in也可以循环对象的属性和方法 有一个问题???style = style但是style对象,只是表层的复制(浅拷贝) c[key] = p[key]; &#125; return c; &#125; var obj = copy(div); obj.style.background = &quot;blue&quot;; obj.style.width = &quot;200px&quot;; console.log(div);//200px console.log(obj);//200px 12345678910111213141516171819202122232425262728var div = &#123; id:&quot;wrap&quot;, style:&#123; width:&quot;100px&quot;, height:&quot;100px&quot;, background:&quot;red&quot; &#125;, click:function()&#123; console.log(&quot;click&quot;); &#125;, children:[&#123;a1:&#123;&#125;&#125;,&#123;a2:&#123;&#125;&#125;,&#123;a3:&#123;&#125;&#125;,&#123;a4:&#123;&#125;&#125;]&#125; //封装函数,就不用一个一个复制function copy(p,c)&#123;//其中c参数是可有有无 var c = c || &#123;&#125;; for (var key in p) &#123; if (typeof p[key] == &quot;object&quot;) &#123; c[key] = p[key].constructor == Array?[]:&#123;&#125;; copy(p[key],c[key]); &#125;else&#123;//浅拷贝//for in也可以循环对象的属性和方法 有一个问题???style = style但是style对象,只是表层的复制(浅拷贝) c[key] = p[key]; &#125; &#125; return c;&#125;var obj = copy(div);console.log(div);//100pxconsole.log(obj);//200px concustructor是可以查找该函数的类型(好用),可以区分对象(object)的类型,但是proto不能区分object对象","tags":[]},{"title":"英意项目","date":"2016-10-21T07:30:37.000Z","path":"2016/10/21/英意项目/","text":"项目总结 html lang=”en” —&gt; 是指该网站是英文网 “zh”:是中文网 清除样式(BFC) 常用 3种 1）创建一个空标签，加clear:both样式 2）加after伪类 3) overflow:hidden 有局限，会将可见部分遮盖了少用：display:inline-block display:table position:absolute(设置在父级元素) 清除样式，一定要是块元素 添加了浮动，就不能在清除浮动 12345.clear:after&#123; content: ''; display: block; clear: both;&#125; 字体网站（中英文）：http://blog.sina.com.cn/s/blog_710225790101244i.html 压缩png格式的图片：https://tinypng.com/ h1 标签只能用1次(标准) jq的官方网站：http://jquery.cuishifeng.cn/ $.fn.extend({})和$.extend({})的区别：调用方法不一样，1.$(window).scrollMove(10)用对象调用 2.$.scrollMove(10)不用对象调用 对象都是独立的，不会相等的 1console.log($(window)==$(window));//false .get(0)是将jq对象转化为js原生对象","tags":[]},{"title":"MAC下SVN的使用","date":"2016-10-21T03:37:25.000Z","path":"2016/10/21/MAC下SVN的使用/","text":"MAC下SVN的使用一、搭建svn服务器1.svnadmin create创建 svn是svn的目录，”1”是一个版本库的目录1$ svnadmin create svn/1 2.配置文件conf文件夹是配置文件夹，选择svnserve.conf配置，如下：1234#anon-access = read #auth-access = write #password-db = passwd #authz-db = authz 去掉这几个前面的#和空格 选择passwd文件设置账号密码1234[users]# harry = harryssecret# sally = sallyssecretadmin = admin 选择authz文件可以配置用户组权限12345678#[group]下是用户组设置 user1代表用户组 = 用户组成员[groups]user1 = admin#[/]下是用户组或用户权限设置 带@代表用户组，否则是用户[/]@user1 = rwadmin = rw 3.启动SVN服务下面”svn”是第一步时创建的svn目录地址1$ svnserve -d -r svn 没有任何输出，则启动成功 4.关闭服务查看svn服务器进程1$ ps -e | grep svnserve 关闭服务器1kill 进程号 二、MAC SVN 命令行1、从版本库文件checkout到本地目录path:svn地址 例：svn://localhost/1 1$ svn checkout path 简写：svn co path 2、添加新的文件到版本库中file:文件名 列：test.html *.html 1$ svn add file 3、提交:将改动的文件提交到版本库提交：svn commit 1$ svn commit -m &quot;提交内容说明&quot; 简写：svn ci -m “提交内容说明” 4、更新:从版本库下载最新文件svn update从版本库下载最新文件 可指定更新的文件或目录和指定版本 1$ svn update 简写：svn up","tags":[]},{"title":"贪吃蛇等小项目的总结","date":"2016-10-21T03:08:39.000Z","path":"2016/10/21/项目js(贪吃蛇,小球碰撞)/","text":"小项目小球的碰撞（中间是有障碍物） 如果小球是用p标签写的效果和div写小球的不一样（原因是p标签有默认的margin值，会影响效果） 解决方案是将p默认的margin值改为0 *{margin:0;padding:0;} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//获取元素//var wrap = document.getElementById(&quot;wrap&quot;);//var div = wrap.children[0];var p = wrap.children[1];var vx = 5;//速度var vy = 5;var x = 0;//改变方向var y = 0;var timer = setInterval(function()&#123; x+=vx; y+=vy; //获取8个值 var l1 = x; var r1 = x+div.offsetWidth; var t1 = y; var b1 = y+div.offsetHeight; var l2 = p.offsetLeft; var r2 = l2+p.offsetWidth; var t2 = p.offsetTop; var b2 = t2+p.offsetHeight; //第三步,比较8个边的碰撞 if (l1&lt;=r2 &amp;&amp; r1&gt;=l2 &amp;&amp; t1&lt;=b2 &amp;&amp; b1&gt;=t2) &#123;//判断已经撞到边 //div右边碰撞p的左边 if (r1-l2&lt;Math.abs(vx) &amp;&amp; vx&gt;0) &#123; vx*=-1; x = l2-div.offsetWidth;//强制转换(会碰到一点点) &#125; //div左边碰撞p的右边 if (r2-l1&lt;Math.abs(vx) &amp;&amp; vx &lt; 0) &#123; vx*=-1; x = r2; &#125; //div的上边碰撞p的下边 if (b2-t1&lt;Math.abs(vy) &amp;&amp; vy&lt;0)&#123; vy*=-1; y = b2; &#125; //div的下边碰撞p的上边 if (b1-t2&lt;Math.abs(vy) &amp;&amp;vy&gt;0)&#123; vy*=-1; y = t2-div.offsetHeight; &#125; &#125; //第一步 if (x&lt;0 || x&gt;wrap.clientWidth-div.offsetWidth) &#123; //会出现一点点的超出,下面是解决问题(强制转换) 碰到一点点边边 if (vx&gt;0) &#123;//vx速度是正数 x = wrap.clientWidth-div.offsetWidth; &#125;else if (vx&lt;0) &#123;//vx速度是负数 x = 0; &#125; vx *= -1; &#125; //第二步 if (y&lt;0 || y&gt;wrap.clientHeight-div.offsetHeight) &#123; if (vy&gt;0) &#123; y = wrap.clientHeight-div.offsetHeight; &#125;else if (vy&lt;0) &#123; y = 0; &#125; vy *= -1; &#125; //判断4个边 div.style.left = x+&quot;px&quot;; div.style.top = y+&quot;px&quot;;&#125;,30); 放大镜 注意点：如果max是用overflow:scroll;obj.scrollTop和obj.scrollLeft是没有单位的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//获取小图框和小图var min = document.querySelector(&quot;.min&quot;);var minImg = document.querySelector(&quot;.min img&quot;);//获取小方块var p = document.querySelector(&apos;p&apos;);//获取大图框 和大图var max = document.querySelector(&quot;.max&quot;);var maxImg = document.querySelector(&quot;.max img&quot;);//第二步min.onmouseenter = function()&#123; p.style.display = &quot;block&quot;; max.style.display = &quot;block&quot;;&#125;min.onmouseleave = function()&#123; p.style.display = &quot;none&quot;; max.style.display = &quot;none&quot;;&#125;//第一步//鼠标移进小框min.onmousemove = function(e)&#123; //再小方块的正中心移动 var x = e.clientX-p.offsetWidth/2; var y = e.clientY-p.offsetHeight/2; if (x&lt;0) &#123; x = 0; &#125;else if (x&gt;min.clientWidth-p.offsetWidth) &#123; x = min.clientWidth-p.offsetWidth; &#125; if (y&lt;0) &#123; y = 0; &#125;else if ( y &gt;min.clientHeight-p.offsetHeight) &#123; y = min.clientHeight-p.offsetHeight; &#125; p.style.left = x+&quot;px&quot;; p.style.top = y+&quot;px&quot;; //第三步 //大图也跟着移动 var scale = min.clientWidth/p.offsetWidth;//比例是大框和小方块 maxImg.style.width = scale*minImg.offsetWidth+&quot;px&quot;;//设置大框的宽度,上面的样式就可以不用另外算 /*maxImg.style.left = -x*scale+&quot;px&quot;; maxImg.style.top = -y*scale + &quot;px&quot;;*/ //97 98行的另一种写法(scroll是没有单位的) max.scrollLeft = x*scale; max.scrollTop = y*scale;&#125; 小方块的拖动事件 注意点：window的滚轮事件，有卷起的那部分，要加上来div.style.left一定要加单位，div块也一定要是定位 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950var div = document.getElementsByTagName(&apos;div&apos;)[0];var winW = window.innerWidth;//屏幕宽var winH = window.innerHeight;//屏幕高div.onmousedown = function (e) &#123; var dx = e.clientX - div.offsetLeft; var dy = e.clientY - div.offsetTop; // 获取滚动条位置 var sTop = document.documentElement.scrollTop || document.body.scrollTop; var sLeft= document.documentElement.scrollLeft || document.body.scrollLeft; document.onmousemove = function(e)&#123; var x = e.clientX - dx; var y = e.clientY - dy; if (x&lt;sLeft) &#123; x = sLeft; &#125;else if(x&gt;winW-div.offsetWidth+sLeft)&#123; x = winW-div.offsetWidth+sLeft; &#125; if(y&lt;sTop)&#123; y = sTop; &#125;else if(y&gt;winH-div.offsetHeight+sTop)&#123; y = winH-div.offsetHeight+sTop; &#125; div.style.left = x + &quot;px&quot;; div.style.top = y + &quot;px&quot;; &#125; return false;&#125;document.onmouseup = function()&#123; document.onmousemove = &quot;&quot;;&#125;window.onscroll = function()&#123; // 获取滚动条位置 var sTop = document.documentElement.scrollTop || document.body.scrollTop; var sLeft= document.documentElement.scrollLeft || document.body.scrollLeft; if (sTop&gt;div.offsetTop) &#123; div.style.top = sTop + &quot;px&quot;; &#125;else if(div.offsetTop&gt;sTop+winH-div.offsetHeight)&#123; div.style.top = sTop+winH-div.offsetHeight + &quot;px&quot;; &#125; console.log(div.offsetTop,sTop+winH-div.offsetHeight) if (sLeft&gt;div.offsetLeft) &#123; div.style.left = sLeft + &quot;px&quot;; &#125;else if(div.offsetLeft&gt;sLeft+winW-div.offsetWidth)&#123; div.style.left = sLeft+winW-div.offsetWidth + &quot;px&quot;; &#125;&#125; 贪吃蛇123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110&lt;body&gt; &lt;div id=&quot;wrap&quot;&gt; &lt;div id=&quot;snake&quot;&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt;var wrap = document.querySelector(&quot;#wrap&quot;);var p = document.querySelector(&quot;p&quot;)var div = wrap.getElementsByTagName(&apos;div&apos;);var x = 0;var y = 0;var speed = 20;var vx = speed;var vy = 0;var bol = false;//用来判断是否按了方向键changeFood()var timer = setInterval(function () &#123; x += vx; y += vy; // 判断撞墙 if (x&lt;0) &#123; x = wrap.clientWidth-20; // gameover() &#125;else if(x&gt;wrap.clientWidth-20)&#123; x = 0; &#125; if (y&lt;0) &#123; y = wrap.clientHeight-20; &#125;else if(y&gt;wrap.clientHeight-20)&#123; y = 0; &#125; //移动蛇身体 for (var i = div.length - 1; i &gt; 0; i--) &#123; div[i].style.left = div[i-1].offsetLeft + &quot;px&quot;; div[i].style.top = div[i-1].offsetTop + &quot;px&quot;; &#125; // div[2].style.left = div[1].offsetLeft + &quot;px&quot;; // div[2].style.top = div[1].offsetTop + &quot;px&quot;; // div[1].style.left = div[0].offsetLeft + &quot;px&quot;; // div[1].style.top = div[0].offsetTop + &quot;px&quot;; div[0].style.left = x + &quot;px&quot;; div[0].style.top = y + &quot;px&quot;; check() bol = false;&#125;,200)//创建蛇的身体function createBody()&#123; var div = document.createElement(&quot;div&quot;); wrap.appendChild(div);&#125;//改变食物的位置function changeFood()&#123; // 计算一行的格子数量 var numx = parseInt(wrap.clientWidth/20) var numy = parseInt(wrap.clientHeight/20) //随机食物位置 var rndx = Math.floor(Math.random()*numx)*20; var rndy = Math.floor(Math.random()*numy)*20; for (var i = 0; i &lt; div.length; i++) &#123; if (rndx==div[i].offsetLeft&amp;&amp;rndy==div[i].offsetTop) &#123; // 判断如果食物位置如果在蛇身上重新调用改变食物的位置函数 return changeFood(); &#125; &#125; p.style.left = rndx + &quot;px&quot;; p.style.top = rndy + &quot;px&quot;;&#125;//吃到食物或者吃到自己function check()&#123; if (x==p.offsetLeft&amp;&amp;y==p.offsetTop) &#123; changeFood() createBody() &#125; for (var i = 4; i &lt; div.length; i++) &#123; if (x==div[i].offsetLeft&amp;&amp;y==div[i].offsetTop) &#123; gameover(); &#125; &#125;&#125;function gameover()&#123; clearInterval(timer); alert(&quot;游戏结束&quot;)&#125;document.onclick = function()&#123; changeFood() createBody()&#125;document.onkeydown = function(e)&#123; switch(e.keyCode)&#123; case 37://左 if(vx==0&amp;&amp;!bol)&#123;vx = -speed;vy = 0;&#125; break; case 38://上 if(vy==0&amp;&amp;!bol)&#123;vx = 0;vy = -speed;&#125; break; case 39://右 if(vx==0&amp;&amp;!bol)&#123;vx = speed;vy = 0;&#125; break; case 40://下 if(vy==0&amp;&amp;!bol)&#123;vx = 0;vy = speed;&#125; break; &#125; bol = true;&#125;","tags":[]},{"title":"封装jq插件","date":"2016-10-19T12:50:04.000Z","path":"2016/10/19/jq封装插件/","text":"jq封装插件留言板 注意点:如果是要创建多个\u0010标签,一定要加var,否则就变成全局\u0010变量(即只能创建一次) 需要引入jquery-3.0.0.min.js和动画效果的jquery.easing.min.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199var $name = $(\"#txt1\"); var $con = $(\"#txt2\"); var $ul = $(\"#message_text ul\"); var $btn = $(\"#btn\"); $btn.on(\"click\",function()&#123; var txt1 = $name.val(); var txt2 = $con.val(); if (txt1 == \"\"|| txt2 == \"\") &#123; alert(\"请填写完整的信息\"); return; &#125; var $li = $('&lt;li&gt;&lt;h3&gt;'+txt1+'&lt;/h3&gt;&lt;p&gt;'+txt2+'&lt;a href=\"###\"&gt;删除&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;');//创建要用var,不然就是全局变量,只能创建一次 $ul.prepend($li); $con.val(\"\"); $con.focus(); $li.slideDown(800,\"easeOutBounce\");//检验是否是被隐藏 var $a = $li.find(\"a\"); $a.on(\"click\",function()&#123; $li.slideUp(800,\"easeOutBounce\",function()&#123; $li.remove(); &#125;); &#125;) &#125;)``` //下面这样的话,只会删除最后一个```javascript var $name = $(\"#txt1\"); var $con = $(\"#txt2\"); var $btn = $(\"#btn\"); var $ul = $(\"#message_text ul\"); var $li; $btn.on(\"click\",function()&#123; var txt1 = $name.val(); var txt2 = $con.val(); $li = $('&lt;li&gt;&lt;h3&gt;'+txt1+'&lt;/h3&gt;&lt;p&gt;'+txt2+'&lt;a href=\"###\"&gt;删除&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;');//前面不加var就是,全局变量,会出现每次都覆盖上一个 $ul.prepend($li); $con.val(\"\"); $con.focus(); $li.slideDown(800,\"easeOutBounce\"); var $a = $li.find(\"a\"); $a.on(\"click\",function()&#123; //总是删除最后一个 $li.slideUp(800,\"easeOutBounce\",function()&#123; $li.remove(); &#125;); &#125;) &#125;)``` ### jq版的easing动画&gt;可以直接使用### 封装大图滚动```javascript$.fn.extend(&#123; swiper:function(options)&#123; var $wrap = $(this); var $inner = $wrap.find(\".inner\"); var $left = $wrap.find(\".left\"); var $right = $wrap.find(\".right\"); var $dd = $wrap.find(\".dd\"); var timer = null;//自动播放的定时器 var defaults = &#123;//默认参数不开 loop:false, btn:false, dd:false, autoPlay:0 &#125; //获取用户设置的参数 覆盖默认参数 for (var key in options) &#123; defaults[key] = options[key]; &#125; //根据设置的数据显示或隐藏左右按钮 if (defaults.btn) &#123; $left.show(); $right.show(); &#125;else&#123; $left.hide(); $right.hide(); &#125; //根据设置的参数显示或隐藏切换点 if (defaults.dd) &#123; $dd.show(); &#125;else&#123; $dd.hide(); &#125; var index = 0; var moveBol = false;//记录是否移动 createD(); //根据图片块的数量创建切换点 function createD()&#123; for (var i = 0;i &lt; $inner.children().length;i++) &#123; var $span = $(\"&lt;span&gt;&lt;/span&gt;\"); $dd.append($span); //tab切换 $span.on(\"click\",function()&#123; // //清空所有点的样式 // $dd.children().removeClass(\"select\"); // //给当前点击的点加上选中样式 // $(this).addClass(\"select\"); index = $(this).index(); //根据点击的第几个点移动inner到指定的位置 move(index); &#125;) &#125; //默认给第一个点加上选中状态 $dd.children().eq(0).addClass(\"select\"); if (defaults.loop) &#123; //无缝滚动,复制第一张放到最后一张,用做无缝滚轮效果 ,加ture是深复制,不加的话只是复制标签 $slide = $inner.children().eq(0).clone(true); $inner.append($slide); &#125; &#125; //下一张 $right.on(\"click\",function()&#123; if (moveBol) &#123;return;&#125;//如果执行了return,那么下面就不能再执行了 index++; // var n = defaults.loop?2:1;//判断是减1还是减2 if (defaults.loop&amp;&amp;index&gt;$inner.children().length-2) &#123;//6-2最后还加了一张 // index = 0; $dd.children().removeClass(\"select\"); $dd.children().eq(0).addClass(\"select\"); moveBol = true;//记录动画开始 //这时的index值是5 $inner.animate(&#123;left:-index*$wrap.innerWidth()&#125;,function()&#123; $inner.css(\"left\",0); moveBol = false;//记录动画结束 &#125;) index = 0; &#125;else&#123; if (index&gt;$inner.children().length-1) &#123; index = $inner.children().length-1; &#125; move(index); &#125; &#125;) //上一张 $left.on(\"click\",function()&#123; if (moveBol) &#123;return;&#125; index--; // var n = defaults.loop?2:1; if (index&lt;0) &#123; if (defaults.loop) &#123; // index = $inner.children().length-1; index = $inner.children().length-2;//4(倒数第二张) 小于0要显示倒数第二张 //直接跳到最后一张(最后一张是第一张的图)然后往上一张 $inner.css(\"left\",-$wrap.innerWidth()*(index+1)); &#125;else&#123; index = 0; &#125; &#125; move(index); &#125;) function move(index)&#123; moveBol = true;//记录动画开始 $dd.children().removeClass(\"select\"); $dd.children().eq(index).addClass(\"select\"); $inner.stop().animate(&#123;//stop()是清除定时器 left:-$wrap.innerWidth()*index, &#125;,function()&#123; moveBol = false;//记录动画结束 &#125;) &#125; //默认是0 if (defaults.autoPlay&gt;0) &#123; autoPlay(defaults.autoPlay) &#125; //主动播放函数 function autoPlay(time)&#123; timer = setInterval(function()&#123; $right.click();//模拟事件,执行下一张的功能 &#125;,time) &#125; &#125;&#125;)// var swiper = new Swiper(\".wrap\",function()&#123;&#125;)$(\".wrap\").swiper(&#123; loop:true, btn:true, dd:true, autoPlay:2000&#125;); #zepto是js的库 注意点:zepto库是将所有的事件分开封装,调用相对应的文件 实例:12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;script type=\"text/javascript\" src=\"event.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\" src=\"touch.js\"&gt;&lt;/script&gt;$(\"div\").css(&#123; //把100改成字符串,效果不一样 width:100, height:100, background:\"red\" &#125;) // $(\"div\").on(\"click\",function()&#123;//zepto是将所有的事件分开来写 // alert(\"这是div\"); // &#125;) $(\"div\").on(\"tap\",function()&#123;//zepto是将所有的事件分开来写,touch是手机端的 alert(\"这是div\"); &#125;)``` ### 多库共存(zepto库和jq库都要用)&gt;用到:jQuery.noConflict()```javascript/*JQuery(\"div\").css(&#123; width:100, height:100, background:\"red\" &#125;)*///清空jq的$函数,赋给abc var abc = jQuery.noConflict(); abc(\"div\").css(&#123; width:100, height:100, background:\"red\" &#125;) console.log($);//undefined&lt;/script&gt;&lt;script type=\"text/javascript\" src=\"zepto.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; console.log($);//zepto的$ $(\"div\").css(&#123; width:200, height:200 &#125;) jq动画的三种写法 方法一: 123$(\"div\").animate(&#123; width:200,&#125;,800,\"easeInOutElastic\") 方法二: 123456789101112131415161718$(\"div\").animate(&#123; width:[200,\"easeInOutBounce\"], height:[200,\"easeInOutElastic\"] &#125;)``` * 方法三:```javascript $(\"div\").animate(&#123; width:500, &#125;,&#123; easing:\"easeInOutBounce\", duration:1000, complete:function()&#123; alert(\"完成\") &#125; &#125;) jq动画的事件 show() hide()显示和隐藏,加了时间参数就会有动画效果 toggle() 上滑(隐藏),下滑(显示)动画效果(改变高度) 会先判断是否隐藏slideUp() slideDown()–必须是display:”none”,才会有动画效果 slideToggle() 渐隐渐显,改变透明度opacity 0-1fadeIn() fadeOut() fadeToggle()fadeTo(0.5) //从当前的透明度渐变到0透明度为0.5的位置 自定义动画animate() delay延时 stop停止动画 (clearInterval)finish()//直接完成动画 注意点:阻止冒泡 ev.stopPropagation() delay:延时只能动画与动画之间 给其他效果是没用的 show和hide默认有动画效果”swing”,也可以用linear 123456$(document).on(\"click\",function()&#123; $(\"div\").animate(&#123; left:500 &#125;,2000).delay().animate(&#123;top:100&#125;,1000) //延时只能动画与动画之间 给其他效果是没用的 例如:$(\"div\").delay(1000).css(\"background\",\"red\");背景的颜色该改变是没有延迟的效果&#125;) //toggle()12345678$('#foo').toggle(showOrHide);//相当于if (showOrHide) &#123; $('#foo').show();&#125; else &#123; $('#foo').hide();&#125;","tags":[]},{"title":"正则及关于正则的实例","date":"2016-10-18T13:43:08.000Z","path":"2016/10/18/jq1/","text":"正则表达式 注意点:search,match,replace是可以用正则表达式 正则表达式是有.test事件 match返回的是数组 1.什么是正则表达式 它是对&lt;mark&gt;字符串&lt;/mark&gt;执行模式匹配的强大工具 ps:把规则说给计算机听 var reg = /abc/g 属性”g”、”i” 和 “m” 分别用于指定全局匹配、区分大小写的匹配和多行匹配 var reg = new RegExp(“abc”,”g”) reg.test(str) 方法用于检测一个字符串是否匹配某个模式. 如果字符串 string 中含有与 RegExpObject 匹配的文本，则返回 true，否则返回 false。 2.字符串方法结合正则使用 search：检索与正则表达式相匹配的值。 match：找到一个或多个正则表达式的匹配。 replace：替换与正则表达式匹配的子串。 split 3.正则表达式 元字符 . :查找单个字符，除了换行和行结束符。(要注意,如果是查找句号(即是.)就要用到转义符) \\w:查找单词字符。(字母和数字) \\d:查找数字。 \\s:查找空白字符。(空格) \\b:匹配单词边界 \\u:匹配汉字 方括号(查找的范围) [abc] :查找方括号之间的任何字符。[a-c] [^abc]:查找任何不在方括号之间的字符。 [0-9]:查找任何从 0 至 9 的数字。 [a-z]:查找任何从小写 a 到小写 z 的字符。 [A-z]:查找任何从大写 A 到小写 z 的字符。 量词 n+ :匹配任何包含至少一个 n 的字符串。 n*:匹配任何包含零个或多个 n 的字符串。 n?:匹配任何包含零个或一个 n 的字符串。(区号202-) n{X}:匹配包含 X 个 n 的序列的字符串。 n{X,Y}:匹配包含 X 或 Y 个 n 的序列的字符串。 n$:匹配任何结尾为 n 的字符串。(一定要) ^n:匹配任何开头为 n 的字符串。 其他 逻辑“或” |：a|b|c 匹配 a 或 b 或 c 中任意一个 实例 查找替换 验证月份 验证日期 去空格(\\trim) 单词边界(\\s) 匹配中文(\\u4e00-\\u9fa5) 123456789101112131415161718192021222324252627282930313233343536373839//实例1:查找替换//静态界面查找内容:&lt;br&gt; &lt;input type=\"text\" id=\"search\"&gt;&lt;br&gt; 替换的内容:&lt;br&gt; &lt;input type=\"text\" id=\"replace\"&gt; &lt;input type=\"button\" value=\"替换\" class=\"btn\"&gt; &lt;div class=\"con\"&gt; 内容a内容b内容c内容a内容b内容c内容a内容b内容c内容a内容b内容c内容a内容b内容c 内容a内容b内容c内容a内容b内容c内容a内容b内容c内容a内容b内容c内容a内容b内容c 内容a内容b内容c内容a内容b内容c内容a内容b内容c内容a内容b内容c内容a内容b内容c 内容a内容b内容c内容a内容b内容c内容a内容b内容c内容a内容b内容c内容a内容b内容c &lt;/div&gt; //js //获取元素 var con = document.querySelector(\".con\"); var search = document.getElementById(\"search\"); var replace = document.getElementById(\"replace\"); var btn = document.querySelector(\".btn\"); btn.onclick = function()&#123; var str = con.innerText;//获取div内容 不用inerHTML是会把标签也当成字符串,把标签也替换 /*方法1*/ var reg = new RegExp(search.value,\"g\");//正则要在点击里面写 str = str.replace(reg,\"&lt;span&gt;\"+replace.value+\"&lt;/span&gt;\");//replaceAll // 方法2 /*str = str.split(search.value).join(\"&lt;span&gt;\"+replace.value+\"&lt;/span&gt;\");//join把逗号换成replace.value拼接 */ //方法3:indexOf查找 subString()截取 /*var index = 0; var str2 = \"\"; var searchV = search.value; while(str.indexOf(search.value,index)&gt;-1)&#123; str2 += str.substring(index,str.indexOf(search.value,index))+\"&lt;span&gt;\"+replace.value+\"&lt;/span&gt;\"; index = str.indexOf(search.value,index)+searchV.length; &#125;*/ con.innerHTML = str2+str.substring(index);//第二个参数不加是表示最后 &#125; 12345678910111213141516//实例2:验证月份//静态页面月份&lt;input type=\"text\"&gt;&lt;span&gt;&lt;/span&gt;//jsvar input = document.querySelector(\"input\");var span = document.querySelector('span');input.onchange = function()&#123; var str = input.value; var reg = /^(0?[1-9]|1[0-2])$/;//^和$是表达只有2位数 //var reg = /^(0?[1-9]|[12]\\d|3[01])$/;// /^(0?[1-9]|[1-2][0-9]|3[0-1])$/ if (reg.test(str)) &#123; span.innerHTML = \"正确\"; &#125;else&#123; span.innerHTML = \"错误\"; &#125;&#125; 12345678910111213//实例3:验证日期var input = document.querySelector(\"input\");var span = document.querySelector('span');input.onchange = function()&#123; var str = input.value; //var reg = /^(0?[1-9]|1[0-2])$/;//^和$是表达只有2位数 var reg = /^(0?[1-9]|[12]\\d|3[01])$/;// /^(0?[1-9]|[1-2][0-9]|3[0-1])$/ if (reg.test(str)) &#123; span.innerHTML = \"正确\"; &#125;else&#123; span.innerHTML = \"错误\"; &#125;&#125; 123456789101112131415//实例4:去空格 //去空格trim str = str.trim(); //var div = document.getElementsByTagName(\"div\")[0]; //var div = document.getElementsByTagName(\" div \")[0];//undefinde function $(str)&#123; // str = str.trim(); str = trim(str); return document.getElementsByTagName(str); &#125; //字符串前后去空格方法 function trim(str)&#123; var reg = /^\\s*|\\s*$/g;//前后的空格可有可无 \\s表示空格 return str.replace(reg,\"\"); &#125; console.log($(\" div \")); 12345678910111213141516171819202122232425262728293031323334//实例5:去边界(\\b)var input = document.querySelector(\"input\");var span = document.querySelector('span');var con = document.querySelector(\".con\");// var reg = /\\bred\\b/;// var str = \"\\\\dhdf\";// span.innerHTML = str;input.onchange = function () &#123; /*var reg = new RegExp(\"\\\\b\"+this.value+\"\\\\b\"); var bol = reg.test(str); if (bol) &#123; span.innerHTML = \"有\"; &#125;else&#123; span.innerHTML = \"没有\"; &#125;*/ //var reg = /\\bto\\b/g;// \\b是单词边界 /\\./g是找到句号 var reg = new RegExp(\"\\\\b\"+this.value+\"\\\\b\",\"g\"); var str = con.innerText; con.innerHTML = str.replace(reg,\"&lt;span&gt;\"+this.value+\"&lt;/span&gt;\");//^ $是&#125;``` ```javascript//实例6:匹配中文var input = document.querySelector(\"input\"); var span = document.querySelector('span'); //匹配中文\\u4e00-\\u9fa5 input.onchange = function()&#123; var reg = /[u4e00-\\u9fa5]/g;//[^]是除了中括号里面的内容 /^([^\\u4e00-\\u9fa5]\\w)&#123;5,20&#125;$/ /^(\\w)&#123;5,20&#125;$/ \\w是包括由字母和数字和下划线,其他的不能 var str = this.value; span.innerHTML = str.match(reg).length; &#125; jQuery 什么是JQ 网址:http://jquery.cuishifeng.cn/(官网) 1.jQuery 是一个 JavaScript 库。 2.jQuery 极大地简化了 JavaScript 编程。 3.jQuery 很容易学习。 jQuery的优势 轻量级, 强大的选择器, 出色的DOM操作, 可靠的事件处理机制, 完善的Ajax(异步处理), 出色的浏览器兼容性, 链式操作方式, 丰富的插件支持, 完善的文档, 开源 注意点:jq第三版本是先执行window.onload = function(){},再执行$(document).ready(function(){}) jq里面的for循环,已经用函数封装好了,不需要再写for循环 123456789window.onload = function()&#123;//先执行 var div = document.getElementById(\"d1\"); alert(\"onload\"); &#125;$(function()&#123; var div = document.getElementById(\"d1\"); alert(\"ready\"); &#125;) //ready onload 选择器 看手册 jQ原生转换为jq1234567891011$(function() &#123;// $(\"li\").css(\"background\",\"green\");console.log($(\"li\"));//组//下面的jq转原生对象// $(\"li\")[2].style.background = \"green\";//原生的方法$(\"li\").get(2).style.background = \"red\";//原生转jq对象var l5 = document.querySelector(\".l5\");// l5.css(\"background\",\"yellow\");元素转不了jq$(l5).css(\"background\",\"yellow\");//原生转jq&#125;) 尺寸位置 注意点:innerWidth innerHeight都是方法 innerWidth()/innerHegiht()包括内边距,不包括边框 outerWidth()/outerHeight()包括边框和内边距 123456789101112131415161718var $div = $(\".wrap div\");var $wrap = $(\".wrap\");//获取div宽高样式的宽和高(注意点),不包括border和paddingconsole.log(\"div的宽\"+$div.width());console.log(\"div的宽\"+$div.width(300));//获取完之和,可以修改//css获取最终样式console.log($div.css(\"width\"));console.log(\"div的高\"+$div.height());console.log(\"wrap的宽\"+$wrap.width());console.log(\"wrap的高\"+$wrap.height());//获取div实际宽高,包括边框和内边距,包括边框和内边距console.log(\"div的宽\"+$div.outerWidth()+\"div的高\"+$div.outerHeight);//获取div的宽高,包括内边距,不包括边框console.log(\"div的宽\"+$div.innerWidth()+\"div的高\"+$div.innerHeight());//根据position获取根据父级的left和top值的,相对原生offsetLeft,offsetTopconsole.log(\"div:posiotion:\"+$div.position().left);//offset获取根据距离窗口的left和Top值的位置值console.log(\"div:offetTop:\"+$div.offset().top) tab切换var $input = $(\"input\"); var $div = $(\"div\"); $input.on(\"click\", function(){ $input.removeClass(\"select\"); $(this).addClass(\"select\"); /* $div.css(\"display\",\"none\"); $div.eq($(this).index()).css(\"display\",\"block\");*/ $div.hide(); $div.eq($(this).index()).show(); // $div.fadeOut(500); // $div.eq($(this).index()).fadeIn(500); $div.slideUp(500); $div.eq($(this).index()).slideDown(500); })","tags":[]},{"title":"js的事件总结,拖拽,冒泡事件","date":"2016-10-15T06:59:41.000Z","path":"2016/10/15/js第28天/","text":"点击事件 onmousedown 鼠标点下 onmouseup 鼠标放开 （可以组成onclick事件） onmousemove 移动 ondblclick 鼠标双击 oncontextmune 鼠标右击 onmouseover 鼠标移进 onmouseout 鼠标移出 onmouseenter 鼠标移进 onmouseleave 鼠标移出 注意点：onmouseover 和 onmouseout 存在冒泡事件的bug(解决方案是用成onmouseenter和onmouseleave) 123456789101112131415&lt;script type=\"text/javascript\"&gt; var img = document.querySelector(\"img\"); img.onmousedown = function()&#123; console.log(\"onmousedown\"); //return false;//阻止事件 &#125; img.onmouseup = function()&#123; console.log(\"onmouseup\"); &#125; img.onclick = function()&#123; console.log(\"onclick\"); &#125; //onmousedown onmouseup onclick&lt;/script&gt; window的自带事件的参数e(有兼容) 总结：var e = e || even;（参数e:是ie8以上支持的，参数event：是ie6以下用的） 一般带参函数，调用不加参数，默认返回undefinde 系统自带的函数，如target,srcElement(是两个兼容的属性)target:非ie srcElement:ie(委托事件,性能的影响) eg:123456789document.onmousemove = function(e)&#123;//onclick 换成onmousemove(鼠标) var e = e || event;//兼容问题 //console.log(e);//传参是ie8以上 //获取屏幕上的位置,是再pc端的 document.body.innerHTML = e.clientX + &quot;,&quot;+e.clientY;//问题:e. &#125; eg:(可以这么理解) —-可以改变默认返回值12345function abc(a)&#123; //a = a || 0;//改变默认值 alert(a); &#125; a();//一般默认是undefind eg:12345678910111213方法一：常用var list = document.getElementsByTagName(&quot;li&quot;);for (var i = 0;i &lt; list.length;i++) &#123; list[i].onclick = function()&#123; this.style.background = &quot;red&quot;; &#125;&#125;方法二：灵活应用var ul = document.querySelector(&quot;ul&quot;); ul.onclick = function(e)&#123; var li = e.target || event.srcElement;//存在兼容问题 li.style.background = &quot;green&quot;;&#125; 事件冒泡 阻止事件冒泡 e.cancelBubble = true; e.stopPropagation();阻止默认事件 e.preventDefault();//非ie e.returnValue = false;//ie return false;//常用(阻止部分的默认事件) 123456789101112var inp = document.querySelector(&quot;input&quot;);var show = document.getElementById(&quot;show&quot;);inp.onclick = function(e)&#123; show.style.display = &quot;none&quot;; e.stopPropagation(); //e.stopPropagation()可以阻止下面的事件的执行 // alert(1);&#125;document.onclick = function()&#123; show.style.display = &quot;block&quot;; // alert(2);&#125; 拖拽物体 注意点：该物体一定要定位，否则没有效果 方法1：用布尔值解决123456789101112131415161718192021var div = document.getElementsByTagName('div')[0];var bol = false;var dx = 0;var dy = 0;div.onmousedown = function (e) &#123; bol = true; // 记录鼠标和DIV左上角位置的距离 dx = e.clientX - div.offsetLeft; dy = e.clientY - div.offsetTop; return false;&#125;document.onmousemove = function(e)&#123; if (!bol) &#123;return&#125;//判断没有按住鼠标就不能拖动 var x = e.clientX - dx; var y = e.clientY - dy; div.style.left = x + \"px\"; div.style.top = y + \"px\";&#125;document.onmouseup = function()&#123; bol = false;&#125; 方法2：不要布尔值12345678910111213141516var div = document.getElementsByTagName('div')[0];div.onmousedown = function (e) &#123; // 记录鼠标和DIV左上角位置的距离 var dx = e.clientX - div.offsetLeft; var dy = e.clientY - div.offsetTop; document.onmousemove = function(e)&#123; var x = e.clientX - dx; var y = e.clientY - dy; div.style.left = x + \"px\"; div.style.top = y + \"px\"; &#125; return false;&#125;document.onmouseup = function()&#123; document.onmousemove = \"\";&#125; 模拟事件12345678910var input = document.getElementsByTagName('input');var i = 0;input[1].onclick = function () &#123; i++; input[0].value = i; input[0].focus();&#125;// setInterval(function()&#123;// input[1].click();// &#125;,100) 表单事件 onfocus 获得焦点时触发的事件 onblur 失去焦点时触发的事件 onchange 当内容发生改变而且失去焦点的时候触发的事件 onselect 选中文本框里面的文字时触发的事件 onsubmit 到内容提交到form表单的时候触发的事件 onreset 内容重置的时候触发 注意点：onsubmit 和 onreset只能设置在form表单上，不能用在其他元素上 window事件 window.onload 页面加载完候触发的事件 window.onscroll 窗口的滚动条滚动的时候触发的事件 window.onresize 窗口大小改变时候触发的事件 123456789101112window.onresize = function () &#123; var winW = document.documentElement.clientWidth; if (winW&lt;480) &#123; document.body.style.background = \"red\";//document.body指向html的body上 &#125;else if(winW&lt;640)&#123; document.body.style.background = \"blue\"; &#125;else if(winW&lt;960)&#123; document.body.style.background = \"yellow\"; &#125;else&#123; document.body.style.background = \"transparent\"; &#125;&#125; 键盘移动div1234567891011121314151617181920212223var div = document.getElementsByTagName('div')[0];var x = 0;var y = 0;var speed = 100;//速度var vx = 0;var vy = 0;setInterval(function()&#123; x += vx; y += vy; div.style.left = x + 'px'; div.style.top = y + 'px';&#125;,200);document.onkeydown = function (e) &#123; if (e.keyCode==37) &#123;//左 vx = -speed;vy = 0; &#125;else if(e.keyCode==38)&#123;//上 vx = 0;vy = -speed; &#125;else if(e.keyCode==39)&#123;//右 vx = speed;vy = 0; &#125;else if(e.keyCode==40)&#123;//下 vx = 0;vy = speed; &#125;&#125; 方块之间的碰撞(方块的拖拽和8个边之间的比较)1234567891011121314151617181920212223242526272829303132333435363738 var div = document.getElementsByTagName('div'); div[0].onmousedown = function (e) &#123; var dx = e.clientX - div[0].offsetLeft; var dy = e.clientY - div[0].offsetTop; document.onmousemove = function(e)&#123; var x = e.clientX - dx; var y = e.clientY - dy; div[0].style.left = x + \"px\"; div[0].style.top = y + \"px\"; var l1 = x; var r1 = x + div[0].offsetWidth; var t1 = y; var b1 = y + div[0].offsetHeight; var l2 = div[1].offsetLeft; var r2 = l2 + div[1].offsetWidth; var t2 = div[1].offsetTop; var b2 = t2 + div[1].offsetHeight; // if (l1&lt;r2 &amp;&amp; r1&gt;l2 &amp;&amp; t1&lt;b2 &amp;&amp; b1&gt;t2) &#123; // div[1].style.background = 'blue'; // &#125;else&#123; // div[1].style.background = 'yellow'; // &#125; if (l1&gt;r2 || r1&lt;l2 || t1&gt;b2 || b1&lt;t2) &#123; div[1].style.background = 'yellow'; &#125;else&#123; div[1].style.background = 'blue'; &#125; &#125; return false;&#125;document.onmouseup = function()&#123; document.onmousemove = \"\";&#125; 小圆球之间的碰撞（思路是用勾股定理）1234567891011121314151617181920212223242526272829 var div = document.getElementsByTagName('div'); div[0].onmousedown = function (e) &#123; var dx = e.clientX - div[0].offsetLeft; var dy = e.clientY - div[0].offsetTop; document.onmousemove = function(e)&#123; var x = e.clientX - dx; var y = e.clientY - dy; div[0].style.left = x + \"px\"; div[0].style.top = y + \"px\"; var a = x - div[1].offsetLeft; var b = y - div[1].offsetTop; var c = Math.sqrt(a*a + b*b); if (c&lt;100) &#123; div[1].style.background = \"blue\"; &#125;else&#123; div[1].style.background = \"yellow\"; &#125; var l2 = div[1].offsetLeft; var t2 = div[1].offsetTop; &#125; return false;&#125;document.onmouseup = function()&#123; document.onmousemove = \"\";&#125;","tags":[]}]